# 39题组合总和 - start参数作用分析

## 核心问题：为什么start不能每次从0开始？

### 问题根源：组合vs排列的本质区别

**组合**: [2,3] 和 [3,2] 是同一个组合，顺序无关
**排列**: [2,3] 和 [3,2] 是不同的排列，顺序重要

### start参数的真正作用：防止重复组合

假设candidates = [2,3,6,7], target = 7

#### ❌ 错误方式：每次从0开始
```cpp
// 如果每次都从i=0开始
for (int i = 0; i < candidates.size(); i++) {
    backtrack(candidates, target-candidates[i], 0, path, result);  // 每次从0开始
}
```

**会产生的搜索树：**
```
                    []
               /  |   |   \
            [2]   [3] [6]  [7]
          / | | \
     [2,2][2,3][2,6][2,7]
```

在[2,2,3]路径中，会产生：
- 先选2，再选2，再选3 → [2,2,3]
- 先选2，再选3，再选2 → [2,3,2] 
- 先选3，再选2，再选2 → [3,2,2]

**结果**: 同一个组合[2,2,3]会被重复生成3次！

#### ✅ 正确方式：从start开始，保证有序选择
```cpp
// 从start开始，确保按顺序选择
for (int i = start; i < candidates.size(); i++) {
    backtrack(candidates, target-candidates[i], i, path, result);  // 下次仍从i开始
}
```

**产生的搜索树：**
```
                    []
               /  |   |   \
            [2]   [3] [6]  [7]
          / | \
     [2,2][2,3][2,6]    ← 只能选择≥当前位置的元素
     /
  [2,2,2]
```

在这种方式下：
- 选择2后，下次只能从位置0(即2)开始，可以选择[2,3,6,7]
- 选择3后，下次只能从位置1(即3)开始，可以选择[3,6,7]
- 这样保证了[2,2,3]只会生成一次

### 关键理解：i 参数的双重作用

1. **允许重复使用**: `backtrack(..., i, ...)` 中的`i`允许再次选择当前元素
2. **避免重复组合**: `i`确保下次选择从当前位置开始，保持有序性

### 具体例子对比

**candidates = [2,3], target = 7**

#### 每次从0开始的错误结果：
```
[2,2,3] ← 通过路径: 2→2→3
[2,3,2] ← 通过路径: 2→3→2 (重复!)
[3,2,2] ← 通过路径: 3→2→2 (重复!)
```

#### 从start开始的正确结果：
```
[2,2,3] ← 通过路径: 2(i=0)→2(i=0)→3(i=1)
```

### 核心洞察

start参数不是控制"能否重复使用元素"，而是控制"按什么顺序生成组合"。

- **元素重复使用**: 通过`i`而不是`i+1`实现
- **避免重复组合**: 通过`start`限制选择范围实现

**记忆口诀**: 
- `i` = 允许重复使用当前元素
- `start` = 避免重复组合的产生

这就是为什么39题的精妙之处：一个简单的参数设计同时解决了两个问题！