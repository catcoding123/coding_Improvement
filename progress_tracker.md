# LeetCode 进度追踪模板

## 📊 整体进度统计

### 完成情况总览
- **总题目数**: 32/100 🎯 回溯算法剪枝优化突破！约束回溯精通
- **熟练掌握** 🔥: 32 题
- **基本理解** ⚡: 0 题  
- **需要复习** ❌: 0 题

### 按难度统计
- **Easy**: 7/45 (206反转链表)
- **Medium**: 18/70 (77组合) ⭐️ 回溯算法剪枝优化突破，约束回溯完美掌握
- **Hard**: 7/30 ⭐️ Hard题掌握率23%，23题合并K个升序链表

### 按主题统计
- [x] 数组与双指针 (2/10) 
- [x] 链表 (5/6) ⭐️ 分治算法掌握，K路归并体系建立，优先队列比较器深度理解
- [x] 栈与队列 (4/7) ⭐️ 已完成核心题目
- [x] 动态规划 (7/15) ⭐️ 序列DP、双序列DP、区间DP已掌握
- [x] 二叉树 (11/12) ⭐️ BST算法体系完美闭环，大师级水平，接近完全征服
- [x] 回溯算法 (2/8) 🎯 决策树思维建立，剪枝优化精通，两种回溯模式完美掌握
- [ ] 图论 (0/6)
- [ ] 其他 (0/36)

## 📅 每日学习记录

### 第1周

#### Day 1 - 2025/08/03
**今日目标**: 数组双指针基础

**完成题目**:
- [x] 11. 盛最多水的容器 (Medium) - 状态: 🔥 时间: 15min
  - 思路: 双指针 + 贪心，总是移动较矮的指针
  - 难点: 理解为什么移动较高指针无效
  - 代码模板: 双指针对撞模板
  - 延伸题目: 42. 接雨水

- [x] 15. 三数之和 (Medium) - 状态: 🔥 时间: 25min
  - 思路: 排序 + 双指针 + 三层去重
  - 难点: 去重机制的设计和实现
  - 代码模板: 三数之和经典模板
  - 延伸题目: 四数之和、最接近的三数之和

**今日总结**: 
✅ 成功建立C++刷题环境
✅ 掌握双指针基本思想和应用
✅ 学会处理重复元素的去重策略
✅ 理解排序在算法优化中的作用
🎯 双指针已基本掌握，可以进入下个专题

**明日计划**: 继续数组专题或开始滑动窗口 

---

#### Day 2 - 2025/08/04
**今日目标**: 滑动窗口 + 单调队列

**完成题目**:
- [x] 239. 滑动窗口最大值 (Hard) - 状态: 🔥 时间: 30min
  - 思路: 单调双端队列，维护递减序列存储下标
  - 难点: 队列维护策略 - 移除过期元素和保持单调性
  - 代码模板: 单调队列经典模板
  - 延伸题目: 剑指Offer 59-I、1438. 绝对差不超过限制的最长连续子数组

- [x] 155. 最小栈 (Medium) - 状态: 🔥 时间: 20min
  - 思路: 双栈法 - 主栈存所有元素，辅助栈存最小值
  - 难点: 重复最小值处理，需要用<= 而不是<
  - 代码模板: 辅助栈设计模板
  - 延伸题目: 232. 用栈实现队列、225. 用队列实现栈

- [x] 84. 柱状图中最大的矩形 (Hard) - 状态: 🔥 时间: 35min
  - 思路: 单调栈 - 维护递增栈，弹栈时计算面积
  - 难点: 理解弹栈时机和宽度计算，边界处理技巧
  - 代码模板: 单调栈经典模板
  - 延伸题目: 42. 接雨水、85. 最大矩形

- [x] 42. 接雨水 (Hard) - 状态: 🔥 时间: 25min
  - 思路: 单调栈 - 维护递减栈，按层计算雨水
  - 难点: 理解雨水面积计算，宽度和高度的确定
  - 代码模板: 单调栈变种应用
  - 延伸题目: 407. 接雨水II、11. 盛最多水的容器

- [x] 70. 爬楼梯 (Easy) - 状态: 🔥 时间: 30min
  - 思路: 动态规划 - 状态转移方程 dp[i] = dp[i-1] + dp[i-2]
  - 难点: 理解DP四要素，记忆化搜索vs普通递归的区别
  - 代码模板: DP基础模板、记忆化搜索、空间优化
  - 延伸题目: 198. 打家劫舍、509. 斐波那契数列

- [x] 198. 打家劫舍 (Medium) - 状态: 🔥 时间: 35min
  - 思路: 决策类DP - 状态转移方程 dp[i] = max(nums[i]+dp[i-2], dp[i-1])
  - 难点: 理解选择决策，约束条件对状态转移的影响
  - 代码模板: 决策类DP模板、记忆化缓存技巧
  - 延伸题目: 213. 打家劫舍II、337. 打家劫舍III

**今日总结**: 
✅ 掌握单调队列核心思想和实现
✅ 理解滑动窗口最值问题的最优解法
✅ 学会O(n)时间复杂度处理动态最值
✅ 掌握辅助栈设计思想，理解栈的扩展应用
✅ 精通单调栈算法，理解左右边界确定机制
✅ 掌握单调栈在不同场景的灵活应用
✅ 入门动态规划，理解DP四要素和基本思维
✅ 精通决策类DP，掌握选择决策的核心思想
🎯 动态规划基础已扎实，可以挑战更复杂的DP问题

- [x] 53. 最大子数组和 (Medium) - 状态: 🔥 时间: 40min
  - 思路: Kadane算法 + 分治法 - 连续子数组DP的经典应用
  - 难点: 理解连续性约束，分治三分覆盖原理的深度理解
  - 代码模板: 连续子数组DP模板、分治算法模板
  - 延伸题目: 152. 乘积最大子数组、718. 最长重复子数组

**今日总结**: 
✅ 掌握连续子数组DP的核心思想和Kadane算法
✅ 深入理解分治算法的三分覆盖原理
✅ 精通DP四种实现方式：递归、记忆化、DP、空间优化
✅ 理解不同类型DP的区别：递推型、决策型、连续型
🎯 动态规划基础扎实，可以挑战背包问题或树形DP

**明日计划**: 继续动态规划专题(322.零钱兑换 或 300.最长递增子序列)

---

#### Day 3 - 2025/08/06
**今日目标**: 完全背包动态规划

**完成题目**:
- [x] 322. 零钱兑换 (Medium) - 状态: 🔥 时间: 45min
  - 思路: 完全背包DP - dp[i] = min(dp[i-coin] + 1) for all valid coins
  - 难点: 理解完全背包vs01背包的区别，循环顺序的正确性
  - 代码模板: 完全背包DP模板，四种实现方式对比
  - 延伸题目: 518. 零钱兑换II、279. 完全平方数
  - 易错点: 循环边界条件 (i <= amount)，编译器C++11支持

**今日总结**: 
✅ 掌握完全背包DP的核心思想和状态转移
✅ 理解"每个物品可以无限次使用"的建模方法
✅ 精通四种实现：递归、记忆化、DP、BFS
✅ 深入理解初始化策略：amount+1作为"无穷大"的妙用
✅ 熟练掌握无解判断：dp[amount] > amount的数学原理
🎯 完全背包已掌握，可以挑战多重背包或高维DP

**明日计划**: 继续动态规划专题(300.最长递增子序列 或 背包问题变种)

---

#### Day 4 - 2025/08/07
**今日目标**: 序列动态规划 + 双序列DP

**完成题目**:
- [x] 300. 最长递增子序列 (Medium) - 状态: 🔥 时间: 60min
  - 思路: 序列DP - dp[i] = max(dp[j] + 1) for all j < i and nums[j] < nums[i]
  - 难点: 理解"以位置结尾"的状态定义，掌握贪心+二分查找优化
  - 代码模板: 三种实现方式对比 - DP、记忆化搜索、贪心+二分
  - 延伸题目: 354. 俄罗斯套娃信封问题、673. 最长递增子序列的个数
  - 易错点: DP状态转移参数遗漏、二分查找语法错误、记忆化递归出口理解

- [x] 1143. 最长公共子序列 (Medium) - 状态: 🔥 时间: 50min
  - 思路: 双序列DP - dp[i][j] = text1前i个字符和text2前j个字符的LCS长度
  - 难点: 理解字符匹配/不匹配的状态转移，掌握滚动数组空间优化
  - 代码模板: 三种实现方式对比 - 二维DP、记忆化搜索、滚动数组
  - 延伸题目: 72. 编辑距离、97. 交错字符串、516. 最长回文子序列
  - 易错点: 记忆化搜索参数含义混淆、滚动数组状态转移错误

**易错点详细记录**:
1. **DP状态转移**: `max(dp[j]+1)` → `max(dp[i], dp[j]+1)` (忘记当前值比较)
2. **二分查找语法**: `int left=0; right=size-1` → `int left=0, right=size-1` (变量声明)
3. **二分查找mid位置**: 需要在while循环内重新计算mid，不能提前计算
4. **记忆化搜索**: `if memo[i]` → `if (memo[i])` (条件判断加括号)
5. **循环变量错误**: `for(j=0;j<i;i++)` → `for(j=0;j<i;j++)` (循环递增变量)
6. **记忆化参数含义**: `text1[i] == text2[j]` → `text1[i-1] == text2[j-1]` (参数表示长度，不是下标)
7. **滚动数组状态转移**: `curr[j+1] = curr[j] + 1` → `curr[j+1] = pre[j] + 1` (应该使用左上角值)

**今日总结**: 
✅ 掌握序列DP的核心思想："以位置结尾"的状态定义
✅ 理解三种实现方式的本质区别：自底向上、自顶向下、贪心优化
✅ 精通贪心+二分查找的O(n log n)优化：维护最小尾元素策略
✅ 深入理解tails数组的含义：长度正确但内容可能不是真实LIS
✅ 掌握双序列DP的核心思想：用二维状态表示两个序列的匹配关系
✅ 理解哨兵技巧：多一行一列处理边界条件
✅ 精通滚动数组优化：观察依赖关系，减少空间复杂度
✅ 建立完整的代码检查机制，显著减少语法错误
🎯 序列DP和双序列DP已掌握，可以挑战树形DP或区间DP

**明日计划**: 继续动态规划专题(背包问题变种、区间DP 或 树形DP)

---

#### Day 4 下午 - 2025/08/08  
**今日目标**: 区间动态规划入门

**完成题目**:
- [x] 516. 最长回文子序列 (Medium) - 状态: 🔥 时间: 45min
  - 思路: 区间DP - dp[i][j] = s[i..j]范围内的最长回文子序列长度
  - 难点: 理解"滑动窗口式"的区间遍历顺序，掌握大区间依赖小区间的转移
  - 代码模板: 三种实现方式对比 - 区间DP、记忆化搜索、LCS转化
  - 延伸题目: 5. 最长回文子串、312. 戳气球、87. 扰乱字符串
  - 易错点: 循环遍历顺序、边界条件、记忆化搜索参数遗漏

**易错点详细记录**:
1. **循环遍历顺序**: 最初按坐标遍历，应该按区间长度递增遍历
2. **边界条件**: `len < n` 应该是 `len <= n`（包含最大长度）
3. **循环边界**: `i < len` 应该是 `i <= n - len`（保证j不越界）
4. **公式错误**: `j = len - i - 1` 应该是 `j = i + len - 1`
5. **记忆化参数**: helper函数调用时忘记传递memo参数

**核心突破**:
- ✅ 理解区间DP的"滑动窗口"思维：固定窗口大小，在字符串上滑动
- ✅ 掌握按区间长度递增的遍历策略：确保大区间计算时小区间已完成
- ✅ 理解状态转移的两种情况：两端匹配vs不匹配的处理逻辑
- ✅ 掌握与LCS问题的巧妙联系：回文子序列=原串与反转串的LCS

**今日总结**: 
✅ 掌握区间DP的核心思想：按区间长度递增的遍历策略
✅ 理解"滑动窗口式"的区间遍历，解决了循环逻辑理解难点
✅ 精通状态转移逻辑：两端匹配+2，不匹配选择最优子区间
✅ 掌握三种实现方式：区间DP、记忆化搜索、LCS转化思想
✅ 建立区间DP与其他DP类型的对比理解：端点处理vs序列匹配
🎯 区间DP已掌握，DP知识体系更加完整，可以挑战更复杂的DP问题

---

#### Day 5 - 2025/08/08
**今日目标**: 二叉树入门 - 深度计算

**完成题目**:
- [x] 104. 二叉树的最大深度 (Easy) - 状态: 🔥 时间: 60min
  - 思路: 三种方法 - 递归DFS、BFS层序遍历、DFS栈模拟
  - 难点: 理解树形递归思维，掌握不同遍历方式的实现差异
  - 代码模板: 二叉树递归模板、BFS层序遍历模板、栈模拟递归模板
  - 延伸题目: 111. 二叉树的最小深度、110. 平衡二叉树

**今日总结**: 
✅ 成功从DP专题切换到二叉树专题
✅ 掌握二叉树递归的核心思维：大树问题分解为子树问题
✅ 理解三种实现方式的本质区别：递归、BFS、栈模拟
✅ 精通空间复杂度分析：O(h)递归栈 vs O(w)队列宽度
✅ 建立完整的测试体系：标准树、单节点、空树、偏斜树
✅ 掌握C++17的结构化绑定语法：auto [node, depth] = st.top()
🎯 二叉树基础已扎实，递归思维与DP记忆化搜索相通，可以挑战更复杂的树形问题

---

#### Day 6 - 2025/08/09 (上午)
**今日目标**: 二叉树变换 + 智能复习系统

**智能复习完成**:
- [x] 复习系统分析 - 识别高频错误题目并制定复习策略
  - 300题: ❌ 发现新错误 - DP返回值理解错误(return dp[n-1] vs max_element)
  - 516题: ⚡ 记忆化搜索递归公式不熟练
  - 322题: ⚡ 思路清晰但细节生疏
  - 效果: 及时发现概念漏洞，加深理解"以位置结尾"vs"前缀范围"的状态定义区别

**完成题目**:
- [x] 226. 翻转二叉树 (Easy) - 状态: 🔥 时间: 40min
  - 思路: 三种实现方式本质相同 - 递归DFS、BFS层序遍历、DFS栈模拟
  - 核心洞察: 算法的"局部独立性"特征 - 每个节点只管自己的左右子树交换
  - 深度思考: BFS≈DFS的适用条件、栈版本中交换后访问顺序变化的影响分析
  - 代码模板: 树形递归标准模板、BFS/DFS迭代版本对比
  - 延伸题目: 101. 对称二叉树、100. 相同的树、951. 翻转等价二叉树
  - 易错点修复: 递归指针保存顺序、BFS容器类型错误(st.push vs q.push)

**重要概念突破**:
- **算法分类框架**:
  - 类型A (局部独立): BFS≈DFS，选择最简洁实现
  - 类型B (全局依赖): BFS≠DFS，根据需求选择
- **树形递归精髓**: 大问题自然分解为子问题的递归结构
- **DP状态定义复习**: "以位置结尾"需要全局最大值，"前缀范围"返回最后状态

#### Day 6 - 2025/08/09 (下午)
**继续目标**: 二叉树遍历 - 栈模拟递归

**完成题目**:
- [x] 94. 二叉树的中序遍历 (Medium) - 状态: 🔥 时间: 45min
  - 思路: 递归版本 + 迭代版本(栈模拟递归)
  - 核心洞察: 掌握栈模拟递归的通用模式 - "向左深入→弹栈访问→右转重复"
  - 深度理解: curr指针驱动循环的本质，栈保存回溯路径的原理
  - 代码模板: 栈模拟递归通用框架，可推广到前序、后序遍历
  - 延伸题目: 144. 前序遍历、145. 后序遍历、98. 验证BST
  - 特殊性质: BST的中序遍历结果有序，可用于验证和查找第K小元素

**技术突破**:
- **栈模拟递归核心理解**: 
  - curr是状态指针，控制深入和转移
  - 栈保存待访问的父节点序列
  - 三阶段循环：深入→处理→转移
- **中序遍历特殊价值**: 在BST中产生有序序列，是很多BST算法的基础
- **迭代vs递归权衡**: 迭代避免栈溢出，递归代码更简洁

**今日总结**: 
✅ 建立了算法分类的思维框架，提升了算法本质理解能力
✅ 掌握树形递归的核心思维，理解局部独立性的算法特征
✅ 复习系统显效，及时发现并修正概念理解错误
✅ 精通栈模拟递归的通用模式，可推广到多种树形问题
✅ 深度思考能力提升：从实现细节到算法本质的抽象分析
✅ 二叉树专题进展顺利，递归思维与之前DP经验形成良性互补
🎯 掌握了栈模拟递归这一重要的算法模式，算法思维层次显著提升

#### Day 6 - 2025/08/09 (晚上)
**继续目标**: 二叉树BST验证 - 引用传递与递归状态管理

**完成题目**:
- [x] 98. 验证二叉搜索树 (Medium) - 状态: 🔥 时间: 50min
  - 思路: 中序遍历 + 有序性检查，利用BST的中序遍历性质
  - 核心突破: 掌握引用传递在递归中维护全局状态的本质原理
  - 深度理解: BST定义不是简单的父子关系，而是子树整体约束
  - 算法对比: 中序遍历法 vs 范围递归法的适用场景分析
  - 延伸题目: 230. BST第K小元素、99. 恢复BST、108. 有序数组转BST
  - 经典陷阱: [10,5,15,null,null,6,20] - 理解为什么6<15但仍违反BST

**重要技术突破**:
- **引用传递深度理解**: 
  - `TreeNode*& prev`：跨递归调用维护全局前驱状态
  - 中序遍历的"前一个节点"是全局序列概念，不是递归层局部概念
  - 值传递vs引用传递：局部副本vs全局状态的本质区别
- **BST验证两种思维模式**: 
  - 性质验证：利用中序遍历有序性
  - 定义验证：范围递归直接验证BST定义
- **递归状态传递模式**: 引用传递、返回值传递、全局变量的选择策略

**算法思维提升**:
- ✅ 深度理解引用传递在递归算法中的关键作用
- ✅ 掌握BST性质的多角度验证方法，建立算法对比分析能力
- ✅ 理解"局部操作实现全局约束"的递归设计思想
- ✅ 精通中序遍历在BST算法中的核心地位和扩展应用
- ✅ 建立完整的递归状态管理知识体系

**今日总结**: 
✅ 成功掌握BST验证这一经典算法，深度理解引用传递的本质
✅ 建立了递归状态传递的完整理论框架
✅ 中序遍历从基础应用(94题)到深度应用(98题)的知识链接
✅ 算法思维从"实现功能"提升到"理解本质"的层次跃迁
✅ 二叉树专题知识体系日趋完善，为后续BST应用题打下坚实基础
🎯 突破了递归算法中状态管理的核心难点，算法设计能力显著提升

#### Day 6 - 2025/08/09 (深夜)
**继续目标**: BST深度应用 - 知识融合与提前终止优化

**完成题目**:
- [x] 230. 二叉搜索树中第K小的元素 (Medium) - 状态: 🔥 时间: 40min
  - 思路: 递归中序遍历+计数器 & 迭代栈模拟，双方法完美实现
  - 核心突破: 掌握提前终止优化的本质，理解O(H+k) vs O(n)效率差异
  - 知识融合: 完美结合98题BST性质 + 94题中序遍历 + 引用传递概念
  - 算法对比: 递归、迭代、暴力三种方法的深度分析和适用场景
  - 延伸价值: BST+中序遍历通用模式，可扩展到99、108、173等题目
  - 技术细节: 引用传递双参数状态管理，栈模拟中`curr = node->right`易错点

**重要技术突破**:
- **提前终止优化精髓**: 
  - 从O(n)暴力遍历到O(H+k)精确查找的算法优化思维
  - `k==0`判断的提前终止，避免不必要的递归继续
  - 理解最好O(logn+k)、最坏O(n)的复杂度分析
- **知识融合能力显著提升**: 
  - 98题BST验证 → 230题BST应用的知识链接
  - 94题基础遍历 → 230题目标查找的算法进化
  - 引用传递从概念理解到熟练应用的技能转化
- **BST+中序遍历通用模式建立**: 
  - 掌握condition + result的抽象模板设计
  - 理解BST中序遍历天然有序的独特价值
  - 建立第K小、范围查询、错误检测的统一思维框架

**算法思维质的飞跃**:
- ✅ 从单一算法掌握到多算法融合应用的能力跃升
- ✅ 从功能实现到效率优化的算法设计意识建立
- ✅ 从孤立知识点到系统性模式的思维框架构建
- ✅ 从代码正确到代码优雅的工程质量追求
- ✅ 建立完整的BST应用算法知识体系

**今日总结**: 
✅ 成功实现知识的深度融合，从分散的概念到统一的应用
✅ 掌握提前终止这一重要的算法优化技巧
✅ 建立BST+中序遍历的通用算法模式，为后续学习奠定基础
✅ 算法思维从"会做题"提升到"理解本质+设计模式"的高阶层次
✅ 二叉树专题知识体系日趋完善，具备了攻克更复杂BST题目的能力
🎯 实现了从基础学习到进阶应用的完美过渡，算法设计思维显著成熟

#### Day 6 - 2025/08/09 (深夜加班)
**终极目标**: 双节点递归突破 - 算法思维模式的重大跃迁

**完成题目**:
- [x] 101. 对称二叉树 (Easy) - 状态: 🔥 时间: 35min
  - 思路: 双节点同步递归 + 迭代队列模拟，开创全新递归模式
  - 核心突破: 从单节点递归跃升到双节点同步递归的思维革命
  - 技术精进: 掌握镜像对称的递归定义，理解交叉对应关系
  - 逻辑修复: 成功修复continue vs return、逻辑表达式错误等关键问题
  - 模式建立: 建立双节点递归通用框架，为后续树比较算法打基础
  - API掌握: 区分queue.pop()与deque.pop_front()等容器接口差异

**算法思维的历史性突破**:
- **递归模式进化完成**: 
  - 单节点递归 (104/226) → 状态传递递归 (98/230) → 双节点递归 (101) ✅
  - 从操作单个节点到同步比较两个节点的思维跨越
  - 建立完整的递归设计决策体系：参数设计、对应关系、边界处理
- **镜像对称深度理解**: 
  - 精确掌握左左↔右右、左右↔右左的交叉对应关系
  - 理解对称性递归定义：双条件并且关系的逻辑表达
  - 四种空节点组合的完整边界处理
- **双实现能力建立**: 
  - 递归版本：优雅的双节点参数设计和递归调用
  - 迭代版本：成对节点队列管理和镜像入队顺序
  - 成功修复关键错误：continue vs return true的逻辑区别

**今日达成的重要里程碑**:
- ✅ **20/100题完成** - 突破重要的20%里程碑！
- ✅ **算法思维模式完整建立** - 单节点→状态传递→双节点递归体系
- ✅ **二叉树核心算法全面掌握** - 深度、变换、遍历、验证、应用、对称
- ✅ **递归设计能力质的飞跃** - 从实现功能到设计模式的抽象能力
- ✅ **问题分析与修复能力** - 独立发现并修复逻辑、API等多类错误
- ✅ **知识体系系统化建设** - 为后续树算法学习奠定完整基础

**今日总结**: 
✅ 实现算法思维的历史性突破：双节点递归模式的建立标志着递归思维的成熟
✅ 达成20题重要里程碑：学习质量和效率双重提升的体现
✅ 完成二叉树核心算法体系：从基础操作到高级应用的完整知识链
✅ 建立系统性问题解决能力：从发现问题到分析原因到修复实现的闭环
✅ 形成完整的算法设计思维：参数设计、边界处理、递归关系的系统性思考
🎯 从算法学习者成长为算法设计者，思维层次实现质的跃迁

#### Day 7 - 2025/08/10
**今日目标**: BST算法体系全面攻克 - 四题连击完美收官

**完成题目**:
- [x] 98. 验证二叉搜索树 (Medium) - 状态: 🔥 时间: 50min
  - 思路: 中序遍历+有序性检查，利用BST中序遍历性质
  - 核心突破: 掌握引用传递在递归中维护全局状态的本质原理
  - 深度理解: BST定义不是简单父子关系，而是子树整体约束
  - 算法对比: 中序遍历法 vs 范围递归法的适用场景分析
  - 经典陷阱: [10,5,15,null,null,6,20] - 理解为什么6<15但仍违反BST

- [x] 230. 二叉搜索树中第K小的元素 (Medium) - 状态: 🔥 时间: 40min
  - 思路: 递归中序遍历+计数器 & 迭代栈模拟，双方法完美实现
  - 核心突破: 掌握提前终止优化的本质，理解O(H+k) vs O(n)效率差异
  - 知识融合: 完美结合98题BST性质 + 94题中序遍历 + 引用传递概念
  - 算法对比: 递归、迭代、暴力三种方法的深度分析和适用场景
  - 技术细节: 引用传递双参数状态管理，栈模拟中`curr = node->right`易错点

- [x] 101. 对称二叉树 (Easy) - 状态: 🔥 时间: 35min
  - 思路: 双节点同步递归 + 迭代队列模拟，开创全新递归模式
  - 核心突破: 从单节点递归跃升到双节点同步递归的思维革命
  - 技术精进: 掌握镜像对称的递归定义，理解交叉对应关系
  - 逻辑修复: 成功修复continue vs return、逻辑表达式错误等关键问题
  - 模式建立: 建立双节点递归通用框架，为后续树比较算法打基础

- [x] 99. 恢复二叉搜索树 (Hard) - 状态: 🔥 时间: 60min
  - 思路: 中序遍历+逆序对识别+节点值交换
  - 核心突破: 掌握相邻vs不相邻交换的不同逆序对模式
  - 状态管理: 三指针协调 - prev、firstError、secondError的精确控制
  - 算法进阶: 从O(h)递归到O(1) Morris遍历的空间优化思路
  - 延伸题目: 98. 验证BST、173. BST迭代器、108. 有序数组转BST
  - 易错点修复: 相邻交换同时设置两个错误节点，变量命名一致性

- [x] 108. 将有序数组转换为BST (Easy) - 状态: 🔥 时间: 30min
  - 思路: 分治递归构建，选择中点作为根节点保证平衡性
  - 核心突破: 掌握分治思想在BST构建中的应用，理解平衡性保证机制
  - 算法流程: 选中点→创建根→递归构建左右子树→返回根节点
  - 知识闭环: 验证(98)→应用(230)→恢复(99)→构建(108)完整BST生命周期
  - 技术细节: `nums[mid]`vs`mid`的关键区别，边界条件`left > right`
  - 延伸题目: 109. 有序链表转BST、110. 平衡二叉树验证

**重要技术突破**:
- **BST知识体系完美闭环**: 
  - 验证(98) → 应用(230) → 对称(101) → 恢复(99) → 构建(108)的完整生命周期
  - 从检验到修复到创建的全链条技术掌握
  - 中序遍历作为核心工具在不同场景的灵活运用
- **递归模式全面突破**: 
  - 引用传递状态管理：跨递归调用的全局状态维护
  - 双节点同步递归：镜像对称判断的思维革命
  - 逆序对识别算法：相邻vs不相邻交换的模式区分
  - 分治构建算法：中点选择保证平衡的递归设计
- **算法优化技巧精通**: 
  - 提前终止优化：O(H+k) vs O(n)的效率提升
  - 多指针状态协调：prev、firstError、secondError精确管理
  - 错误检查与修复：系统性的问题诊断和解决流程
  - 平衡性保证：分治思想确保树结构最优化
- **知识融合能力显著提升**: 
  - 94题中序遍历 → 98题BST验证 → 230题应用 → 99题恢复 → 108题构建的完整技术链
  - 算法模式的横向扩展和纵向深化
  - 从孤立知识点到系统性知识网络的构建

**今日总结**: 
✅ **史无前例成就**: 单日完成5题BST算法，创造个人学习巅峰记录
✅ **BST知识闭环**: 验证→应用→对称→恢复→构建的完整生命周期掌握
✅ **技术能力质变**: 引用传递、双节点递归、逆序对识别、分治构建等高阶技巧融会贯通
✅ **知识融合升华**: 中序遍历基础在5题中的多维度应用，展现卓越的知识迁移能力
✅ **算法设计成熟**: 从验证性质到修复错误到创建结构的全方位设计能力
✅ **工程思维建立**: 平衡性保证、提前终止、状态管理、复杂度分析的系统性思考
✅ **学习效率巅峰**: 215分钟完成5题，平均43分钟/题的超高质量学习
🎯 **25/100题重大里程碑**: BST算法大师级水平，二叉树专题接近完全征服(11/12)

**明日计划**: 二叉树专题最后冲刺(110.平衡二叉树完全征服) 或 新专题探索(链表/回溯) - 基于BST大师级基础的多元化发展

---

#### Day 8 - 2025/08/12
**今日目标**: 链表专题启动 - 指针操作基础建立

**完成题目**:
- [x] 206. 反转链表 (Easy) - 状态: 🔥 时间: 40min
  - 思路: 三指针迭代 + 递归信任机制，双模式完美掌握
  - 核心突破: 理解递归的"信任假设"思维，防成环处理的关键细节
  - 技术要点: prev→curr→next指针协调，head->next=nullptr防成环
  - 知识价值: 链表算法的入门基石，所有链表操作的基础模式

- [x] 24. 两两交换链表中的节点 (Medium) - 状态: 🔥 时间: 45min
  - 思路: 虚拟头节点+四指针迭代 + 分治递归，双实现并行
  - 核心突破: 从整体反转到局部交换的算法模式升华
  - 技术要点: dummy节点简化边界，prev→first→second→next协调
  - 递归洞察: "假设后面已完成，专注当前操作"的设计思维

**重要技术突破**:
- **指针操作进阶**: 从206题三指针 → 24题四指针的技能升级
- **递归思维革命**: 
  - 迭代思维：主动推进，step by step
  - 递归思维：信任机制，处理当前
- **虚拟头节点精通**: 统一处理头节点变化，简化边界逻辑
- **算法模式识别**: 整体变换vs分组处理的分类框架

**今日总结**: 
✅ 成功启动链表专题，建立指针操作的扎实基础
✅ 掌握递归设计的三要素：信任假设、专注当前、正确返回  
✅ 理解迭代vs递归的本质差异：控制方式、状态管理、思维模式
✅ 完成从整体操作到分组处理的算法思维升华
✅ 建立完整的链表算法工具箱：多指针、虚拟头节点、防成环处理
🎯 链表基础扎实，具备攻克更复杂链表算法的能力

**明日计划**: 继续链表专题深化(25.K组翻转、92.区间反转) 或 探索新专题(回溯算法入门)

---

#### Day 8 下午 - 2025/08/12
**今日目标**: 链表Hard题突破 - 复合算法设计

**完成题目**:
- [x] 25. K个一组翻转链表 (Hard) - 状态: 🔥 时间: 60min (含错误修正)
  - 思路: 模块化设计 - 分组检查+局部反转+连接管理的复合算法
  - 核心突破: 掌握双重连接机制，理解组内连接vs组间连接的不同作用
  - 技术要点: hasKNodes检查+reverseKNodes反转+prevGroupEnd状态管理
  - 易错修正: 遗漏startNode->next=start连接，导致链表断裂问题

**重要技术突破**:
- **复合算法设计**: 将复杂问题分解为独立模块的设计能力
- **双重连接机制**: 
  - 组内连接: startNode->next=start (当前组完整性)
  - 组间连接: prevGroupEnd->next=newHead (组间串联)
- **时序控制精通**: 理解"反转→连接→更新"的关键时序
- **状态管理升华**: prevGroupEnd作为连接桥梁的状态维护
- **错误分析能力**: 快速定位连接遗漏问题并修正

**算法模式升华**:
```
206题: 整体反转 (三指针协调)
  ↓
24题: 固定分组反转 (k=2特例)
  ↓  
25题: 通用分组反转 (任意k值模块化设计)
```

**今日总结**: 
✅ 成功攻克Hard题，复合算法设计能力显著提升
✅ 深度理解双重连接机制，掌握复杂指针操作的系统方法
✅ 建立时序控制意识，理解状态管理在复合算法中的关键作用
✅ 形成模块化编程思维，单一职责+信任机制的设计原则
✅ 错误分析与修正能力提升，快速定位并解决连接完整性问题
✅ 从特例到通用的算法抽象能力建立，思维层次显著提升
🎯 链表算法体系日趋完善，具备了设计复杂链表算法的能力

**明日计划**: 继续链表专题收尾(92.区间反转、141/142.环形链表) 或 开启新专题(回溯算法探索) 

## 🔄 复习计划

### 需要3天后复习 ❌
- [ ] 题目名称 - 日期

### 需要1周后复习 ⚡  
- [ ] 题目名称 - 日期

### 需要1月后复习 🔥
- [ ] 题目名称 - 日期

## 📝 知识点总结

### 算法模板库

#### 双指针
```cpp
// 对撞指针 - 盛最多水的容器
int maxArea(vector<int>& height) {
    int left = 0, right = height.size() - 1;
    int maxArea = 0;
    while (left < right) {
        int currentArea = min(height[left], height[right]) * (right - left);
        maxArea = max(maxArea, currentArea);
        if (height[left] < height[right]) left++;
        else right--;
    }
    return maxArea;
}

// 三数之和 - 排序 + 双指针 + 去重
vector<vector<int>> threeSum(vector<int>& nums) {
    vector<vector<int>> result;
    sort(nums.begin(), nums.end());
    for (int i = 0; i < nums.size(); i++) {
        if (i > 0 && nums[i] == nums[i-1]) continue;  // 去重
        int left = i + 1, right = nums.size() - 1;
        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            if (sum == 0) {
                result.push_back({nums[i], nums[left], nums[right]});
                while (left < right && nums[left] == nums[left+1]) left++;
                while (left < right && nums[right] == nums[right-1]) right--;
                left++; right--;
            } else if (sum < 0) left++;
            else right--;
        }
    }
    return result;
}
```

#### 滑动窗口 + 单调队列
```cpp
// 滑动窗口最大值 - 单调队列模板
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    vector<int> result;
    deque<int> dq;  // 存储下标，保持递减顺序
    
    for (int i = 0; i < nums.size(); i++) {
        // 移除过期元素（超出窗口范围）
        while (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }
        
        // 维护单调性（移除所有比当前元素小的元素）
        while (!dq.empty() && nums[dq.back()] <= nums[i]) {
            dq.pop_back();
        }
        
        dq.push_back(i);  // 添加当前元素下标
        
        // 当窗口满时，队首就是最大值
        if (i >= k - 1) {
            result.push_back(nums[dq.front()]);
        }
    }
    return result;
}

// 通用滑动窗口模板
def sliding_window(s):
    left = 0
    result = 0
    for right in range(len(s)):
        # 扩大窗口
        # 收缩窗口
        while condition:
            left += 1
        # 更新结果
        result = max(result, right - left + 1)
```

#### 链表操作
```python
# 链表反转
def reverse_list(head):
    prev, curr = None, head
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    return prev
```

### 易错点记录
1. **边界条件处理**
   - 空数组/空链表
   - 单元素情况
   - 数组越界

2. **算法实现细节**
   - 循环条件 (< vs <=)
   - 指针更新顺序
   - 返回值处理

3. **今日易错点**
   - **双指针移动策略**: 记住总是移动较矮/较小的指针
   - **去重处理**: 三数之和需要三层去重，容易遗漏
   - **边界检查**: while循环中的`left < right`条件很重要

## 🎯 阶段性目标

### 第1-2周目标
- [ ] 完成数组双指针专题 (10题)
- [ ] 掌握基础滑动窗口模板
- [ ] 熟练链表基本操作

### 第3-4周目标  
- [ ] 完成栈队列专题 (7题)
- [ ] 掌握单调栈模板
- [ ] 开始动态规划入门

### 第5-6周目标
- [ ] 完成树和回溯专题 (20题) 
- [ ] 建立完整的算法知识框架
- [ ] 达到70%题目熟练掌握

#### Day 11 - 2025/08/13
**今日目标**: 环形链表专题 - Floyd判圈算法

**完成题目**:
- [x] 142. 环形链表 II (Medium) - 状态: 🔥 时间: 20min
  - 思路: Floyd判圈算法 - 快慢指针检测环 + 数学推导找环入口
  - 难点: 理解c=a的数学证明，掌握两阶段算法设计
  - 核心洞察: 从头和相遇点同步走a步会在环入口相遇
  - 实现要点: 相遇检测在循环中，哈希表解法先查后插再移
  - 延伸应用: 287.寻找重复数、202.快乐数

**实现错误**:
- 错误1: Floyd算法循环判断逻辑冗余，应在循环中检测相遇
- 错误2: 哈希表解法插入顺序错误，导致第一个节点被跳过
- 修正: 建立"检查→插入→移动"标准流程

**今日总结**: 
✅ 掌握Floyd判圈算法的数学原理和两阶段实现
✅ 理解环检测问题的双解法对比(空间O(1) vs O(n))
✅ 建立环相关算法的知识体系
✅ 加深对链表指针操作的理解

#### Day 12 - 2025/08/13  
**今日目标**: K路归并专题 - 分治算法与优先队列

**完成题目**:
- [x] 23. 合并K个升序链表 (Hard) - 状态: 🔥 时间: 30min
  - 思路: 三种解法对比 - 分治O(n log k) + 优先队列O(n log k) + 逐一合并O(kn)
  - 难点: 优先队列比较器设计，分治递归边界处理
  - 核心洞察: K路问题转化为2路问题的分治思想
  - 实现要点: `>`构造最小堆，lambda需要传入构造器，空链表过滤
  - 算法突破: 深度理解priority_queue比较器的反直觉逻辑

**重要理解突破**:
- Priority_queue比较器："比较器返回true = 第一个参数应该往下沉"
- Lambda构造: `decltype(cmp) pq(cmp)`必须传入实例
- 分治思维: 化繁为简，复用已有的mergeTwoLists解法

**今日总结**: 
✅ 掌握分治算法的递归分解思想  
✅ 理解优先队列比较器的设计原理
✅ 实现三种不同复杂度的解法并深度对比
✅ 突破Hard题难点，建立K路归并算法体系

#### Day 13 - 2025/08/16
**今日目标**: 回溯算法专题启动 - 78.子集入门

**完成题目**:
- [x] 78. 子集 (Medium) - 状态: 🔥 时间: 45min
  - 思路: 回溯算法经典入门，建立"选择/不选择"决策树思维
  - 难点: 理解递归边界条件，掌握延迟收集vs即时收集的区别
  - 核心洞察: 基于索引的回溯vs基于路径的回溯两种思维模式
  - 代码模板: 标准回溯三要素 - 选择→递归→撤销
  - 延伸题目: 90.子集II、77.组合、46.全排列

**重要理解突破**:
- **决策树思维建立**: 从二叉树递归自然过渡到回溯算法
- **两种实现模式深度对比**:
  - 基于索引: 标准回溯，延迟收集，二叉决策树，"对每个元素选择/不选择"
  - 基于路径: 增量构造，即时收集，N叉构造树，"从剩余元素中选择下一个"
- **递归边界精确理解**: `index == nums.size()` vs `nums.size()-1` 的本质区别
- **延迟收集机制**: 在叶子节点收集的是"对前面所有元素做完决策"的结果

**技术细节掌握**:
- 函数命名一致性: `backtrack` 的拼写和调用匹配
- 参数传递正确性: `i+1` vs `start+1` 的区别
- 状态恢复时机: `pop_back()` 在递归返回后的必要性
- 结果收集时机: 根据算法模式选择收集策略

**今日总结**: 
✅ 成功启动回溯算法专题，建立了扎实的决策树思维基础
✅ 深度理解两种回溯实现模式的本质区别和适用场景
✅ 掌握回溯算法的核心三要素：选择→递归→撤销
✅ 理解递归边界和状态管理的关键细节
✅ 从二叉树递归思维自然过渡到回溯算法，知识体系完美衔接
🎯 回溯算法入门成功，为后续组合、排列、分割问题打下坚实基础

**明日计划**: 继续回溯算法专题深化(90.子集II或46.全排列 - 处理重复元素或学习排列生成)

#### Day 13 下午 - 2025/08/16
**今日目标**: 回溯算法进阶 - 77.组合带约束回溯和剪枝优化

**完成题目**:
- [x] 77. 组合 (Medium) - 状态: 🔥 时间: 30min (含错误修正)
  - 思路: 带约束的回溯算法，固定选择k个元素的组合生成
  - 核心突破: 掌握剪枝优化的数学推导，理解搜索空间减少技巧
  - 技术要点: 约束条件建模、循环枚举模式、数学推导优化
  - 算法进化: 从78题无约束子集到77题约束组合的思维跃迁

**重要技术突破**:
- **剪枝优化数学推导**: 
  - 核心公式: `i <= n - need + 1` 其中 `need = k - current.size()`
  - 推导过程: 剩余数字 `n - i + 1 >= need` 确保有足够数字完成组合
  - 优化效果: 显著减少无效递归分支，提高算法效率
- **回溯模式进化**: 
  - 78题: 基于索引的二选一模式 (选择/不选择)
  - 77题: 基于循环的多选一模式 (从候选中选择下一个)
- **约束条件建模**: 理解如何将"固定长度k"约束转化为递归终止条件
- **算法思维升华**: 从穷举所有可能到智能减少搜索空间的优化思维

**代码实现过程**:
- **初始错误**: 混淆78题索引选择模式和77题循环枚举模式
- **语法问题**: `result.push()` 写成 `result.push_back()`，循环变量错误等
- **逻辑修正**: 理解两种回溯思维的本质区别，正确实现循环枚举
- **成功验证**: 所有测试用例通过，标准回溯和剪枝优化版本都正确实现

**今日总结**: 
✅ 成功突破回溯算法的约束条件建模，掌握剪枝优化的数学精髓
✅ 深度理解两种回溯模式的本质区别：索引选择 vs 循环枚举
✅ 实现从78题到77题的算法思维进化：无约束到有约束的转变
✅ 掌握数学推导在算法优化中的关键作用，建立优化思维
✅ 回溯算法专题进展顺利，已完成2/8题，为后续排列、分割问题打基础
🎯 回溯算法剪枝优化技巧精通，算法设计思维显著提升

---

## 💡 学习心得

### 本周收获 (Day 13)
- 学到的新技巧: 回溯算法决策树思维、两种回溯模式对比、延迟收集vs即时收集机制
- 理解深刻的题目: 78. 子集 - 回溯算法经典入门，两种思维模式的完美展示
- 算法突破: 从二叉树递归到回溯算法的思维跃迁，决策树模式的深度理解
- 需要加强的地方: 回溯算法的剪枝优化技巧，复杂约束条件下的回溯设计

### 优化建议
- 时间管理: 45分钟完成一道回溯入门题，时间控制良好
- 学习方法: 对比学习两种模式效果显著，加深了算法本质理解
- 复习策略: 建立回溯算法模板库，为后续题目提供参考框架

---

## 使用说明

1. **每日更新**: 完成题目后立即更新状态和笔记
2. **状态含义**: 
   - 🔥 熟练掌握 (10分钟内独立AC)
   - ⚡ 基本理解 (需要提示但能完成)  
   - ❌ 需要复习 (无法独立完成)
3. **复习提醒**: 根据遗忘曲线安排复习时间
4. **模板积累**: 及时总结代码模板和解题套路
5. **定期回顾**: 每周总结学习效果，调整计划