# LeetCode 进度追踪模板

## 📊 整体进度统计

### 完成情况总览
- **总题目数**: 21/100 🎯 突破20题里程碑！
- **熟练掌握** 🔥: 21 题
- **基本理解** ⚡: 0 题  
- **需要复习** ❌: 0 题

### 按难度统计
- **Easy**: 4/45
- **Medium**: 12/70
- **Hard**: 5/30 ⭐️ Hard题掌握率显著提升

### 按主题统计
- [x] 数组与双指针 (2/10) 
- [ ] 链表 (0/6) 
- [x] 栈与队列 (4/7) ⭐️ 已完成核心题目
- [x] 动态规划 (7/15) ⭐️ 序列DP、双序列DP、区间DP已掌握
- [x] 二叉树 (7/12) ⭐️ BST算法体系全面掌握，逆序对识别+状态管理突破
- [ ] 回溯算法 (0/8)
- [ ] 图论 (0/6)
- [ ] 其他 (0/36)

## 📅 每日学习记录

### 第1周

#### Day 1 - 2025/08/03
**今日目标**: 数组双指针基础

**完成题目**:
- [x] 11. 盛最多水的容器 (Medium) - 状态: 🔥 时间: 15min
  - 思路: 双指针 + 贪心，总是移动较矮的指针
  - 难点: 理解为什么移动较高指针无效
  - 代码模板: 双指针对撞模板
  - 延伸题目: 42. 接雨水

- [x] 15. 三数之和 (Medium) - 状态: 🔥 时间: 25min
  - 思路: 排序 + 双指针 + 三层去重
  - 难点: 去重机制的设计和实现
  - 代码模板: 三数之和经典模板
  - 延伸题目: 四数之和、最接近的三数之和

**今日总结**: 
✅ 成功建立C++刷题环境
✅ 掌握双指针基本思想和应用
✅ 学会处理重复元素的去重策略
✅ 理解排序在算法优化中的作用
🎯 双指针已基本掌握，可以进入下个专题

**明日计划**: 继续数组专题或开始滑动窗口 

---

#### Day 2 - 2025/08/04
**今日目标**: 滑动窗口 + 单调队列

**完成题目**:
- [x] 239. 滑动窗口最大值 (Hard) - 状态: 🔥 时间: 30min
  - 思路: 单调双端队列，维护递减序列存储下标
  - 难点: 队列维护策略 - 移除过期元素和保持单调性
  - 代码模板: 单调队列经典模板
  - 延伸题目: 剑指Offer 59-I、1438. 绝对差不超过限制的最长连续子数组

- [x] 155. 最小栈 (Medium) - 状态: 🔥 时间: 20min
  - 思路: 双栈法 - 主栈存所有元素，辅助栈存最小值
  - 难点: 重复最小值处理，需要用<= 而不是<
  - 代码模板: 辅助栈设计模板
  - 延伸题目: 232. 用栈实现队列、225. 用队列实现栈

- [x] 84. 柱状图中最大的矩形 (Hard) - 状态: 🔥 时间: 35min
  - 思路: 单调栈 - 维护递增栈，弹栈时计算面积
  - 难点: 理解弹栈时机和宽度计算，边界处理技巧
  - 代码模板: 单调栈经典模板
  - 延伸题目: 42. 接雨水、85. 最大矩形

- [x] 42. 接雨水 (Hard) - 状态: 🔥 时间: 25min
  - 思路: 单调栈 - 维护递减栈，按层计算雨水
  - 难点: 理解雨水面积计算，宽度和高度的确定
  - 代码模板: 单调栈变种应用
  - 延伸题目: 407. 接雨水II、11. 盛最多水的容器

- [x] 70. 爬楼梯 (Easy) - 状态: 🔥 时间: 30min
  - 思路: 动态规划 - 状态转移方程 dp[i] = dp[i-1] + dp[i-2]
  - 难点: 理解DP四要素，记忆化搜索vs普通递归的区别
  - 代码模板: DP基础模板、记忆化搜索、空间优化
  - 延伸题目: 198. 打家劫舍、509. 斐波那契数列

- [x] 198. 打家劫舍 (Medium) - 状态: 🔥 时间: 35min
  - 思路: 决策类DP - 状态转移方程 dp[i] = max(nums[i]+dp[i-2], dp[i-1])
  - 难点: 理解选择决策，约束条件对状态转移的影响
  - 代码模板: 决策类DP模板、记忆化缓存技巧
  - 延伸题目: 213. 打家劫舍II、337. 打家劫舍III

**今日总结**: 
✅ 掌握单调队列核心思想和实现
✅ 理解滑动窗口最值问题的最优解法
✅ 学会O(n)时间复杂度处理动态最值
✅ 掌握辅助栈设计思想，理解栈的扩展应用
✅ 精通单调栈算法，理解左右边界确定机制
✅ 掌握单调栈在不同场景的灵活应用
✅ 入门动态规划，理解DP四要素和基本思维
✅ 精通决策类DP，掌握选择决策的核心思想
🎯 动态规划基础已扎实，可以挑战更复杂的DP问题

- [x] 53. 最大子数组和 (Medium) - 状态: 🔥 时间: 40min
  - 思路: Kadane算法 + 分治法 - 连续子数组DP的经典应用
  - 难点: 理解连续性约束，分治三分覆盖原理的深度理解
  - 代码模板: 连续子数组DP模板、分治算法模板
  - 延伸题目: 152. 乘积最大子数组、718. 最长重复子数组

**今日总结**: 
✅ 掌握连续子数组DP的核心思想和Kadane算法
✅ 深入理解分治算法的三分覆盖原理
✅ 精通DP四种实现方式：递归、记忆化、DP、空间优化
✅ 理解不同类型DP的区别：递推型、决策型、连续型
🎯 动态规划基础扎实，可以挑战背包问题或树形DP

**明日计划**: 继续动态规划专题(322.零钱兑换 或 300.最长递增子序列)

---

#### Day 3 - 2025/08/06
**今日目标**: 完全背包动态规划

**完成题目**:
- [x] 322. 零钱兑换 (Medium) - 状态: 🔥 时间: 45min
  - 思路: 完全背包DP - dp[i] = min(dp[i-coin] + 1) for all valid coins
  - 难点: 理解完全背包vs01背包的区别，循环顺序的正确性
  - 代码模板: 完全背包DP模板，四种实现方式对比
  - 延伸题目: 518. 零钱兑换II、279. 完全平方数
  - 易错点: 循环边界条件 (i <= amount)，编译器C++11支持

**今日总结**: 
✅ 掌握完全背包DP的核心思想和状态转移
✅ 理解"每个物品可以无限次使用"的建模方法
✅ 精通四种实现：递归、记忆化、DP、BFS
✅ 深入理解初始化策略：amount+1作为"无穷大"的妙用
✅ 熟练掌握无解判断：dp[amount] > amount的数学原理
🎯 完全背包已掌握，可以挑战多重背包或高维DP

**明日计划**: 继续动态规划专题(300.最长递增子序列 或 背包问题变种)

---

#### Day 4 - 2025/08/07
**今日目标**: 序列动态规划 + 双序列DP

**完成题目**:
- [x] 300. 最长递增子序列 (Medium) - 状态: 🔥 时间: 60min
  - 思路: 序列DP - dp[i] = max(dp[j] + 1) for all j < i and nums[j] < nums[i]
  - 难点: 理解"以位置结尾"的状态定义，掌握贪心+二分查找优化
  - 代码模板: 三种实现方式对比 - DP、记忆化搜索、贪心+二分
  - 延伸题目: 354. 俄罗斯套娃信封问题、673. 最长递增子序列的个数
  - 易错点: DP状态转移参数遗漏、二分查找语法错误、记忆化递归出口理解

- [x] 1143. 最长公共子序列 (Medium) - 状态: 🔥 时间: 50min
  - 思路: 双序列DP - dp[i][j] = text1前i个字符和text2前j个字符的LCS长度
  - 难点: 理解字符匹配/不匹配的状态转移，掌握滚动数组空间优化
  - 代码模板: 三种实现方式对比 - 二维DP、记忆化搜索、滚动数组
  - 延伸题目: 72. 编辑距离、97. 交错字符串、516. 最长回文子序列
  - 易错点: 记忆化搜索参数含义混淆、滚动数组状态转移错误

**易错点详细记录**:
1. **DP状态转移**: `max(dp[j]+1)` → `max(dp[i], dp[j]+1)` (忘记当前值比较)
2. **二分查找语法**: `int left=0; right=size-1` → `int left=0, right=size-1` (变量声明)
3. **二分查找mid位置**: 需要在while循环内重新计算mid，不能提前计算
4. **记忆化搜索**: `if memo[i]` → `if (memo[i])` (条件判断加括号)
5. **循环变量错误**: `for(j=0;j<i;i++)` → `for(j=0;j<i;j++)` (循环递增变量)
6. **记忆化参数含义**: `text1[i] == text2[j]` → `text1[i-1] == text2[j-1]` (参数表示长度，不是下标)
7. **滚动数组状态转移**: `curr[j+1] = curr[j] + 1` → `curr[j+1] = pre[j] + 1` (应该使用左上角值)

**今日总结**: 
✅ 掌握序列DP的核心思想："以位置结尾"的状态定义
✅ 理解三种实现方式的本质区别：自底向上、自顶向下、贪心优化
✅ 精通贪心+二分查找的O(n log n)优化：维护最小尾元素策略
✅ 深入理解tails数组的含义：长度正确但内容可能不是真实LIS
✅ 掌握双序列DP的核心思想：用二维状态表示两个序列的匹配关系
✅ 理解哨兵技巧：多一行一列处理边界条件
✅ 精通滚动数组优化：观察依赖关系，减少空间复杂度
✅ 建立完整的代码检查机制，显著减少语法错误
🎯 序列DP和双序列DP已掌握，可以挑战树形DP或区间DP

**明日计划**: 继续动态规划专题(背包问题变种、区间DP 或 树形DP)

---

#### Day 4 下午 - 2025/08/08  
**今日目标**: 区间动态规划入门

**完成题目**:
- [x] 516. 最长回文子序列 (Medium) - 状态: 🔥 时间: 45min
  - 思路: 区间DP - dp[i][j] = s[i..j]范围内的最长回文子序列长度
  - 难点: 理解"滑动窗口式"的区间遍历顺序，掌握大区间依赖小区间的转移
  - 代码模板: 三种实现方式对比 - 区间DP、记忆化搜索、LCS转化
  - 延伸题目: 5. 最长回文子串、312. 戳气球、87. 扰乱字符串
  - 易错点: 循环遍历顺序、边界条件、记忆化搜索参数遗漏

**易错点详细记录**:
1. **循环遍历顺序**: 最初按坐标遍历，应该按区间长度递增遍历
2. **边界条件**: `len < n` 应该是 `len <= n`（包含最大长度）
3. **循环边界**: `i < len` 应该是 `i <= n - len`（保证j不越界）
4. **公式错误**: `j = len - i - 1` 应该是 `j = i + len - 1`
5. **记忆化参数**: helper函数调用时忘记传递memo参数

**核心突破**:
- ✅ 理解区间DP的"滑动窗口"思维：固定窗口大小，在字符串上滑动
- ✅ 掌握按区间长度递增的遍历策略：确保大区间计算时小区间已完成
- ✅ 理解状态转移的两种情况：两端匹配vs不匹配的处理逻辑
- ✅ 掌握与LCS问题的巧妙联系：回文子序列=原串与反转串的LCS

**今日总结**: 
✅ 掌握区间DP的核心思想：按区间长度递增的遍历策略
✅ 理解"滑动窗口式"的区间遍历，解决了循环逻辑理解难点
✅ 精通状态转移逻辑：两端匹配+2，不匹配选择最优子区间
✅ 掌握三种实现方式：区间DP、记忆化搜索、LCS转化思想
✅ 建立区间DP与其他DP类型的对比理解：端点处理vs序列匹配
🎯 区间DP已掌握，DP知识体系更加完整，可以挑战更复杂的DP问题

---

#### Day 5 - 2025/08/08
**今日目标**: 二叉树入门 - 深度计算

**完成题目**:
- [x] 104. 二叉树的最大深度 (Easy) - 状态: 🔥 时间: 60min
  - 思路: 三种方法 - 递归DFS、BFS层序遍历、DFS栈模拟
  - 难点: 理解树形递归思维，掌握不同遍历方式的实现差异
  - 代码模板: 二叉树递归模板、BFS层序遍历模板、栈模拟递归模板
  - 延伸题目: 111. 二叉树的最小深度、110. 平衡二叉树

**今日总结**: 
✅ 成功从DP专题切换到二叉树专题
✅ 掌握二叉树递归的核心思维：大树问题分解为子树问题
✅ 理解三种实现方式的本质区别：递归、BFS、栈模拟
✅ 精通空间复杂度分析：O(h)递归栈 vs O(w)队列宽度
✅ 建立完整的测试体系：标准树、单节点、空树、偏斜树
✅ 掌握C++17的结构化绑定语法：auto [node, depth] = st.top()
🎯 二叉树基础已扎实，递归思维与DP记忆化搜索相通，可以挑战更复杂的树形问题

---

#### Day 6 - 2025/08/09 (上午)
**今日目标**: 二叉树变换 + 智能复习系统

**智能复习完成**:
- [x] 复习系统分析 - 识别高频错误题目并制定复习策略
  - 300题: ❌ 发现新错误 - DP返回值理解错误(return dp[n-1] vs max_element)
  - 516题: ⚡ 记忆化搜索递归公式不熟练
  - 322题: ⚡ 思路清晰但细节生疏
  - 效果: 及时发现概念漏洞，加深理解"以位置结尾"vs"前缀范围"的状态定义区别

**完成题目**:
- [x] 226. 翻转二叉树 (Easy) - 状态: 🔥 时间: 40min
  - 思路: 三种实现方式本质相同 - 递归DFS、BFS层序遍历、DFS栈模拟
  - 核心洞察: 算法的"局部独立性"特征 - 每个节点只管自己的左右子树交换
  - 深度思考: BFS≈DFS的适用条件、栈版本中交换后访问顺序变化的影响分析
  - 代码模板: 树形递归标准模板、BFS/DFS迭代版本对比
  - 延伸题目: 101. 对称二叉树、100. 相同的树、951. 翻转等价二叉树
  - 易错点修复: 递归指针保存顺序、BFS容器类型错误(st.push vs q.push)

**重要概念突破**:
- **算法分类框架**:
  - 类型A (局部独立): BFS≈DFS，选择最简洁实现
  - 类型B (全局依赖): BFS≠DFS，根据需求选择
- **树形递归精髓**: 大问题自然分解为子问题的递归结构
- **DP状态定义复习**: "以位置结尾"需要全局最大值，"前缀范围"返回最后状态

#### Day 6 - 2025/08/09 (下午)
**继续目标**: 二叉树遍历 - 栈模拟递归

**完成题目**:
- [x] 94. 二叉树的中序遍历 (Medium) - 状态: 🔥 时间: 45min
  - 思路: 递归版本 + 迭代版本(栈模拟递归)
  - 核心洞察: 掌握栈模拟递归的通用模式 - "向左深入→弹栈访问→右转重复"
  - 深度理解: curr指针驱动循环的本质，栈保存回溯路径的原理
  - 代码模板: 栈模拟递归通用框架，可推广到前序、后序遍历
  - 延伸题目: 144. 前序遍历、145. 后序遍历、98. 验证BST
  - 特殊性质: BST的中序遍历结果有序，可用于验证和查找第K小元素

**技术突破**:
- **栈模拟递归核心理解**: 
  - curr是状态指针，控制深入和转移
  - 栈保存待访问的父节点序列
  - 三阶段循环：深入→处理→转移
- **中序遍历特殊价值**: 在BST中产生有序序列，是很多BST算法的基础
- **迭代vs递归权衡**: 迭代避免栈溢出，递归代码更简洁

**今日总结**: 
✅ 建立了算法分类的思维框架，提升了算法本质理解能力
✅ 掌握树形递归的核心思维，理解局部独立性的算法特征
✅ 复习系统显效，及时发现并修正概念理解错误
✅ 精通栈模拟递归的通用模式，可推广到多种树形问题
✅ 深度思考能力提升：从实现细节到算法本质的抽象分析
✅ 二叉树专题进展顺利，递归思维与之前DP经验形成良性互补
🎯 掌握了栈模拟递归这一重要的算法模式，算法思维层次显著提升

#### Day 6 - 2025/08/09 (晚上)
**继续目标**: 二叉树BST验证 - 引用传递与递归状态管理

**完成题目**:
- [x] 98. 验证二叉搜索树 (Medium) - 状态: 🔥 时间: 50min
  - 思路: 中序遍历 + 有序性检查，利用BST的中序遍历性质
  - 核心突破: 掌握引用传递在递归中维护全局状态的本质原理
  - 深度理解: BST定义不是简单的父子关系，而是子树整体约束
  - 算法对比: 中序遍历法 vs 范围递归法的适用场景分析
  - 延伸题目: 230. BST第K小元素、99. 恢复BST、108. 有序数组转BST
  - 经典陷阱: [10,5,15,null,null,6,20] - 理解为什么6<15但仍违反BST

**重要技术突破**:
- **引用传递深度理解**: 
  - `TreeNode*& prev`：跨递归调用维护全局前驱状态
  - 中序遍历的"前一个节点"是全局序列概念，不是递归层局部概念
  - 值传递vs引用传递：局部副本vs全局状态的本质区别
- **BST验证两种思维模式**: 
  - 性质验证：利用中序遍历有序性
  - 定义验证：范围递归直接验证BST定义
- **递归状态传递模式**: 引用传递、返回值传递、全局变量的选择策略

**算法思维提升**:
- ✅ 深度理解引用传递在递归算法中的关键作用
- ✅ 掌握BST性质的多角度验证方法，建立算法对比分析能力
- ✅ 理解"局部操作实现全局约束"的递归设计思想
- ✅ 精通中序遍历在BST算法中的核心地位和扩展应用
- ✅ 建立完整的递归状态管理知识体系

**今日总结**: 
✅ 成功掌握BST验证这一经典算法，深度理解引用传递的本质
✅ 建立了递归状态传递的完整理论框架
✅ 中序遍历从基础应用(94题)到深度应用(98题)的知识链接
✅ 算法思维从"实现功能"提升到"理解本质"的层次跃迁
✅ 二叉树专题知识体系日趋完善，为后续BST应用题打下坚实基础
🎯 突破了递归算法中状态管理的核心难点，算法设计能力显著提升

#### Day 6 - 2025/08/09 (深夜)
**继续目标**: BST深度应用 - 知识融合与提前终止优化

**完成题目**:
- [x] 230. 二叉搜索树中第K小的元素 (Medium) - 状态: 🔥 时间: 40min
  - 思路: 递归中序遍历+计数器 & 迭代栈模拟，双方法完美实现
  - 核心突破: 掌握提前终止优化的本质，理解O(H+k) vs O(n)效率差异
  - 知识融合: 完美结合98题BST性质 + 94题中序遍历 + 引用传递概念
  - 算法对比: 递归、迭代、暴力三种方法的深度分析和适用场景
  - 延伸价值: BST+中序遍历通用模式，可扩展到99、108、173等题目
  - 技术细节: 引用传递双参数状态管理，栈模拟中`curr = node->right`易错点

**重要技术突破**:
- **提前终止优化精髓**: 
  - 从O(n)暴力遍历到O(H+k)精确查找的算法优化思维
  - `k==0`判断的提前终止，避免不必要的递归继续
  - 理解最好O(logn+k)、最坏O(n)的复杂度分析
- **知识融合能力显著提升**: 
  - 98题BST验证 → 230题BST应用的知识链接
  - 94题基础遍历 → 230题目标查找的算法进化
  - 引用传递从概念理解到熟练应用的技能转化
- **BST+中序遍历通用模式建立**: 
  - 掌握condition + result的抽象模板设计
  - 理解BST中序遍历天然有序的独特价值
  - 建立第K小、范围查询、错误检测的统一思维框架

**算法思维质的飞跃**:
- ✅ 从单一算法掌握到多算法融合应用的能力跃升
- ✅ 从功能实现到效率优化的算法设计意识建立
- ✅ 从孤立知识点到系统性模式的思维框架构建
- ✅ 从代码正确到代码优雅的工程质量追求
- ✅ 建立完整的BST应用算法知识体系

**今日总结**: 
✅ 成功实现知识的深度融合，从分散的概念到统一的应用
✅ 掌握提前终止这一重要的算法优化技巧
✅ 建立BST+中序遍历的通用算法模式，为后续学习奠定基础
✅ 算法思维从"会做题"提升到"理解本质+设计模式"的高阶层次
✅ 二叉树专题知识体系日趋完善，具备了攻克更复杂BST题目的能力
🎯 实现了从基础学习到进阶应用的完美过渡，算法设计思维显著成熟

#### Day 6 - 2025/08/09 (深夜加班)
**终极目标**: 双节点递归突破 - 算法思维模式的重大跃迁

**完成题目**:
- [x] 101. 对称二叉树 (Easy) - 状态: 🔥 时间: 35min
  - 思路: 双节点同步递归 + 迭代队列模拟，开创全新递归模式
  - 核心突破: 从单节点递归跃升到双节点同步递归的思维革命
  - 技术精进: 掌握镜像对称的递归定义，理解交叉对应关系
  - 逻辑修复: 成功修复continue vs return、逻辑表达式错误等关键问题
  - 模式建立: 建立双节点递归通用框架，为后续树比较算法打基础
  - API掌握: 区分queue.pop()与deque.pop_front()等容器接口差异

**算法思维的历史性突破**:
- **递归模式进化完成**: 
  - 单节点递归 (104/226) → 状态传递递归 (98/230) → 双节点递归 (101) ✅
  - 从操作单个节点到同步比较两个节点的思维跨越
  - 建立完整的递归设计决策体系：参数设计、对应关系、边界处理
- **镜像对称深度理解**: 
  - 精确掌握左左↔右右、左右↔右左的交叉对应关系
  - 理解对称性递归定义：双条件并且关系的逻辑表达
  - 四种空节点组合的完整边界处理
- **双实现能力建立**: 
  - 递归版本：优雅的双节点参数设计和递归调用
  - 迭代版本：成对节点队列管理和镜像入队顺序
  - 成功修复关键错误：continue vs return true的逻辑区别

**今日达成的重要里程碑**:
- ✅ **20/100题完成** - 突破重要的20%里程碑！
- ✅ **算法思维模式完整建立** - 单节点→状态传递→双节点递归体系
- ✅ **二叉树核心算法全面掌握** - 深度、变换、遍历、验证、应用、对称
- ✅ **递归设计能力质的飞跃** - 从实现功能到设计模式的抽象能力
- ✅ **问题分析与修复能力** - 独立发现并修复逻辑、API等多类错误
- ✅ **知识体系系统化建设** - 为后续树算法学习奠定完整基础

**今日总结**: 
✅ 实现算法思维的历史性突破：双节点递归模式的建立标志着递归思维的成熟
✅ 达成20题重要里程碑：学习质量和效率双重提升的体现
✅ 完成二叉树核心算法体系：从基础操作到高级应用的完整知识链
✅ 建立系统性问题解决能力：从发现问题到分析原因到修复实现的闭环
✅ 形成完整的算法设计思维：参数设计、边界处理、递归关系的系统性思考
🎯 从算法学习者成长为算法设计者，思维层次实现质的跃迁

#### Day 7 - 2025/08/10
**今日目标**: BST高阶应用 - 逆序对识别与恢复算法

**完成题目**:
- [x] 99. 恢复二叉搜索树 (Hard) - 状态: 🔥 时间: 60min
  - 思路: 中序遍历+逆序对识别+节点值交换
  - 核心突破: 掌握相邻vs不相邻交换的不同逆序对模式
  - 状态管理: 三指针协调 - prev、firstError、secondError的精确控制
  - 算法进阶: 从O(h)递归到O(1) Morris遍历的空间优化思路
  - 延伸题目: 98. 验证BST、173. BST迭代器、108. 有序数组转BST
  - 易错点修复: 相邻交换同时设置两个错误节点，变量命名一致性

**重要技术突破**:
- **逆序对模式深度理解**: 
  - 相邻交换: 一个逆序对`[1,3,2,4]` → 首次发现时同时设置firstError和secondError
  - 不相邻交换: 两个逆序对`[1,4,3,2,5]` → 首次设置firstError，第二次仅更新secondError
- **状态管理进阶**: 
  - 引用传递`TreeNode*& prev`维护全局前驱状态
  - 三指针协调管理：prev跟踪遍历、firstError记录第一个错误、secondError动态更新
- **BST恢复算法体系**: 
  - 检测阶段：中序遍历识别逆序对违反BST性质
  - 分析阶段：根据逆序对数量判断交换模式
  - 修复阶段：精确交换两个错误节点的值
- **算法设计思维成熟**: 
  - 从问题分析到模式识别到算法设计的完整流程
  - 边界条件处理、状态转移管理、错误检查机制的系统性思考

**今日总结**: 
✅ 成功攻克BST系列最具挑战性的Hard题，标志着BST知识体系的完整建立
✅ 掌握逆序对识别这一重要的算法模式，可推广到多种序列分析问题
✅ 精通复杂状态管理：多指针协调、引用传递、全局状态维护的高阶技巧
✅ 建立从检测→分析→修复的完整算法设计流程，提升系统性解决问题能力
✅ 二叉树专题知识融合：104/226基础→94/98进阶→230/101高级→99顶级的完美进阶
✅ 算法思维从"实现功能"到"设计模式"再到"系统架构"的层次跃迁
🎯 BST算法体系全面掌握，具备攻克任何BST相关问题的技术实力

**明日计划**: 二叉树专题收官(108.构建BST完善知识闭环) 或 新专题探索(链表/回溯) - 基于扎实基础的多元发展 

## 🔄 复习计划

### 需要3天后复习 ❌
- [ ] 题目名称 - 日期

### 需要1周后复习 ⚡  
- [ ] 题目名称 - 日期

### 需要1月后复习 🔥
- [ ] 题目名称 - 日期

## 📝 知识点总结

### 算法模板库

#### 双指针
```cpp
// 对撞指针 - 盛最多水的容器
int maxArea(vector<int>& height) {
    int left = 0, right = height.size() - 1;
    int maxArea = 0;
    while (left < right) {
        int currentArea = min(height[left], height[right]) * (right - left);
        maxArea = max(maxArea, currentArea);
        if (height[left] < height[right]) left++;
        else right--;
    }
    return maxArea;
}

// 三数之和 - 排序 + 双指针 + 去重
vector<vector<int>> threeSum(vector<int>& nums) {
    vector<vector<int>> result;
    sort(nums.begin(), nums.end());
    for (int i = 0; i < nums.size(); i++) {
        if (i > 0 && nums[i] == nums[i-1]) continue;  // 去重
        int left = i + 1, right = nums.size() - 1;
        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            if (sum == 0) {
                result.push_back({nums[i], nums[left], nums[right]});
                while (left < right && nums[left] == nums[left+1]) left++;
                while (left < right && nums[right] == nums[right-1]) right--;
                left++; right--;
            } else if (sum < 0) left++;
            else right--;
        }
    }
    return result;
}
```

#### 滑动窗口 + 单调队列
```cpp
// 滑动窗口最大值 - 单调队列模板
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    vector<int> result;
    deque<int> dq;  // 存储下标，保持递减顺序
    
    for (int i = 0; i < nums.size(); i++) {
        // 移除过期元素（超出窗口范围）
        while (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }
        
        // 维护单调性（移除所有比当前元素小的元素）
        while (!dq.empty() && nums[dq.back()] <= nums[i]) {
            dq.pop_back();
        }
        
        dq.push_back(i);  // 添加当前元素下标
        
        // 当窗口满时，队首就是最大值
        if (i >= k - 1) {
            result.push_back(nums[dq.front()]);
        }
    }
    return result;
}

// 通用滑动窗口模板
def sliding_window(s):
    left = 0
    result = 0
    for right in range(len(s)):
        # 扩大窗口
        # 收缩窗口
        while condition:
            left += 1
        # 更新结果
        result = max(result, right - left + 1)
```

#### 链表操作
```python
# 链表反转
def reverse_list(head):
    prev, curr = None, head
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    return prev
```

### 易错点记录
1. **边界条件处理**
   - 空数组/空链表
   - 单元素情况
   - 数组越界

2. **算法实现细节**
   - 循环条件 (< vs <=)
   - 指针更新顺序
   - 返回值处理

3. **今日易错点**
   - **双指针移动策略**: 记住总是移动较矮/较小的指针
   - **去重处理**: 三数之和需要三层去重，容易遗漏
   - **边界检查**: while循环中的`left < right`条件很重要

## 🎯 阶段性目标

### 第1-2周目标
- [ ] 完成数组双指针专题 (10题)
- [ ] 掌握基础滑动窗口模板
- [ ] 熟练链表基本操作

### 第3-4周目标  
- [ ] 完成栈队列专题 (7题)
- [ ] 掌握单调栈模板
- [ ] 开始动态规划入门

### 第5-6周目标
- [ ] 完成树和回溯专题 (20题) 
- [ ] 建立完整的算法知识框架
- [ ] 达到70%题目熟练掌握

## 💡 学习心得

### 本周收获 (Day 1)
- 学到的新技巧: 双指针对撞模式、三层去重策略、排序辅助算法优化
- 理解深刻的题目: 15. 三数之和 - 将O(n³)优化到O(n²)的经典案例
- 需要加强的地方: 去重逻辑的细节处理，需要多练习类似题目

### 优化建议
- 时间管理:
- 学习方法:
- 复习策略:

---

## 使用说明

1. **每日更新**: 完成题目后立即更新状态和笔记
2. **状态含义**: 
   - 🔥 熟练掌握 (10分钟内独立AC)
   - ⚡ 基本理解 (需要提示但能完成)  
   - ❌ 需要复习 (无法独立完成)
3. **复习提醒**: 根据遗忘曲线安排复习时间
4. **模板积累**: 及时总结代码模板和解题套路
5. **定期回顾**: 每周总结学习效果，调整计划