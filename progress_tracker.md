# LeetCode 进度追踪模板

## 📊 整体进度统计

### 完成情况总览
- **总题目数**: 17/100
- **熟练掌握** 🔥: 17 题
- **基本理解** ⚡: 0 题  
- **需要复习** ❌: 0 题

### 按难度统计
- **Easy**: 3/45
- **Medium**: 10/70
- **Hard**: 4/30

### 按主题统计
- [x] 数组与双指针 (2/10) 
- [ ] 链表 (0/6) 
- [x] 栈与队列 (4/7) ⭐️ 已完成核心题目
- [x] 动态规划 (7/15) ⭐️ 序列DP、双序列DP、区间DP已掌握
- [x] 二叉树 (3/12) ⭐️ 递归思维、BFS/DFS遍历、树形变换、栈模拟递归已掌握
- [ ] 回溯算法 (0/8)
- [ ] 图论 (0/6)
- [ ] 其他 (0/36)

## 📅 每日学习记录

### 第1周

#### Day 1 - 2025/08/03
**今日目标**: 数组双指针基础

**完成题目**:
- [x] 11. 盛最多水的容器 (Medium) - 状态: 🔥 时间: 15min
  - 思路: 双指针 + 贪心，总是移动较矮的指针
  - 难点: 理解为什么移动较高指针无效
  - 代码模板: 双指针对撞模板
  - 延伸题目: 42. 接雨水

- [x] 15. 三数之和 (Medium) - 状态: 🔥 时间: 25min
  - 思路: 排序 + 双指针 + 三层去重
  - 难点: 去重机制的设计和实现
  - 代码模板: 三数之和经典模板
  - 延伸题目: 四数之和、最接近的三数之和

**今日总结**: 
✅ 成功建立C++刷题环境
✅ 掌握双指针基本思想和应用
✅ 学会处理重复元素的去重策略
✅ 理解排序在算法优化中的作用
🎯 双指针已基本掌握，可以进入下个专题

**明日计划**: 继续数组专题或开始滑动窗口 

---

#### Day 2 - 2025/08/04
**今日目标**: 滑动窗口 + 单调队列

**完成题目**:
- [x] 239. 滑动窗口最大值 (Hard) - 状态: 🔥 时间: 30min
  - 思路: 单调双端队列，维护递减序列存储下标
  - 难点: 队列维护策略 - 移除过期元素和保持单调性
  - 代码模板: 单调队列经典模板
  - 延伸题目: 剑指Offer 59-I、1438. 绝对差不超过限制的最长连续子数组

- [x] 155. 最小栈 (Medium) - 状态: 🔥 时间: 20min
  - 思路: 双栈法 - 主栈存所有元素，辅助栈存最小值
  - 难点: 重复最小值处理，需要用<= 而不是<
  - 代码模板: 辅助栈设计模板
  - 延伸题目: 232. 用栈实现队列、225. 用队列实现栈

- [x] 84. 柱状图中最大的矩形 (Hard) - 状态: 🔥 时间: 35min
  - 思路: 单调栈 - 维护递增栈，弹栈时计算面积
  - 难点: 理解弹栈时机和宽度计算，边界处理技巧
  - 代码模板: 单调栈经典模板
  - 延伸题目: 42. 接雨水、85. 最大矩形

- [x] 42. 接雨水 (Hard) - 状态: 🔥 时间: 25min
  - 思路: 单调栈 - 维护递减栈，按层计算雨水
  - 难点: 理解雨水面积计算，宽度和高度的确定
  - 代码模板: 单调栈变种应用
  - 延伸题目: 407. 接雨水II、11. 盛最多水的容器

- [x] 70. 爬楼梯 (Easy) - 状态: 🔥 时间: 30min
  - 思路: 动态规划 - 状态转移方程 dp[i] = dp[i-1] + dp[i-2]
  - 难点: 理解DP四要素，记忆化搜索vs普通递归的区别
  - 代码模板: DP基础模板、记忆化搜索、空间优化
  - 延伸题目: 198. 打家劫舍、509. 斐波那契数列

- [x] 198. 打家劫舍 (Medium) - 状态: 🔥 时间: 35min
  - 思路: 决策类DP - 状态转移方程 dp[i] = max(nums[i]+dp[i-2], dp[i-1])
  - 难点: 理解选择决策，约束条件对状态转移的影响
  - 代码模板: 决策类DP模板、记忆化缓存技巧
  - 延伸题目: 213. 打家劫舍II、337. 打家劫舍III

**今日总结**: 
✅ 掌握单调队列核心思想和实现
✅ 理解滑动窗口最值问题的最优解法
✅ 学会O(n)时间复杂度处理动态最值
✅ 掌握辅助栈设计思想，理解栈的扩展应用
✅ 精通单调栈算法，理解左右边界确定机制
✅ 掌握单调栈在不同场景的灵活应用
✅ 入门动态规划，理解DP四要素和基本思维
✅ 精通决策类DP，掌握选择决策的核心思想
🎯 动态规划基础已扎实，可以挑战更复杂的DP问题

- [x] 53. 最大子数组和 (Medium) - 状态: 🔥 时间: 40min
  - 思路: Kadane算法 + 分治法 - 连续子数组DP的经典应用
  - 难点: 理解连续性约束，分治三分覆盖原理的深度理解
  - 代码模板: 连续子数组DP模板、分治算法模板
  - 延伸题目: 152. 乘积最大子数组、718. 最长重复子数组

**今日总结**: 
✅ 掌握连续子数组DP的核心思想和Kadane算法
✅ 深入理解分治算法的三分覆盖原理
✅ 精通DP四种实现方式：递归、记忆化、DP、空间优化
✅ 理解不同类型DP的区别：递推型、决策型、连续型
🎯 动态规划基础扎实，可以挑战背包问题或树形DP

**明日计划**: 继续动态规划专题(322.零钱兑换 或 300.最长递增子序列)

---

#### Day 3 - 2025/08/06
**今日目标**: 完全背包动态规划

**完成题目**:
- [x] 322. 零钱兑换 (Medium) - 状态: 🔥 时间: 45min
  - 思路: 完全背包DP - dp[i] = min(dp[i-coin] + 1) for all valid coins
  - 难点: 理解完全背包vs01背包的区别，循环顺序的正确性
  - 代码模板: 完全背包DP模板，四种实现方式对比
  - 延伸题目: 518. 零钱兑换II、279. 完全平方数
  - 易错点: 循环边界条件 (i <= amount)，编译器C++11支持

**今日总结**: 
✅ 掌握完全背包DP的核心思想和状态转移
✅ 理解"每个物品可以无限次使用"的建模方法
✅ 精通四种实现：递归、记忆化、DP、BFS
✅ 深入理解初始化策略：amount+1作为"无穷大"的妙用
✅ 熟练掌握无解判断：dp[amount] > amount的数学原理
🎯 完全背包已掌握，可以挑战多重背包或高维DP

**明日计划**: 继续动态规划专题(300.最长递增子序列 或 背包问题变种)

---

#### Day 4 - 2025/08/07
**今日目标**: 序列动态规划 + 双序列DP

**完成题目**:
- [x] 300. 最长递增子序列 (Medium) - 状态: 🔥 时间: 60min
  - 思路: 序列DP - dp[i] = max(dp[j] + 1) for all j < i and nums[j] < nums[i]
  - 难点: 理解"以位置结尾"的状态定义，掌握贪心+二分查找优化
  - 代码模板: 三种实现方式对比 - DP、记忆化搜索、贪心+二分
  - 延伸题目: 354. 俄罗斯套娃信封问题、673. 最长递增子序列的个数
  - 易错点: DP状态转移参数遗漏、二分查找语法错误、记忆化递归出口理解

- [x] 1143. 最长公共子序列 (Medium) - 状态: 🔥 时间: 50min
  - 思路: 双序列DP - dp[i][j] = text1前i个字符和text2前j个字符的LCS长度
  - 难点: 理解字符匹配/不匹配的状态转移，掌握滚动数组空间优化
  - 代码模板: 三种实现方式对比 - 二维DP、记忆化搜索、滚动数组
  - 延伸题目: 72. 编辑距离、97. 交错字符串、516. 最长回文子序列
  - 易错点: 记忆化搜索参数含义混淆、滚动数组状态转移错误

**易错点详细记录**:
1. **DP状态转移**: `max(dp[j]+1)` → `max(dp[i], dp[j]+1)` (忘记当前值比较)
2. **二分查找语法**: `int left=0; right=size-1` → `int left=0, right=size-1` (变量声明)
3. **二分查找mid位置**: 需要在while循环内重新计算mid，不能提前计算
4. **记忆化搜索**: `if memo[i]` → `if (memo[i])` (条件判断加括号)
5. **循环变量错误**: `for(j=0;j<i;i++)` → `for(j=0;j<i;j++)` (循环递增变量)
6. **记忆化参数含义**: `text1[i] == text2[j]` → `text1[i-1] == text2[j-1]` (参数表示长度，不是下标)
7. **滚动数组状态转移**: `curr[j+1] = curr[j] + 1` → `curr[j+1] = pre[j] + 1` (应该使用左上角值)

**今日总结**: 
✅ 掌握序列DP的核心思想："以位置结尾"的状态定义
✅ 理解三种实现方式的本质区别：自底向上、自顶向下、贪心优化
✅ 精通贪心+二分查找的O(n log n)优化：维护最小尾元素策略
✅ 深入理解tails数组的含义：长度正确但内容可能不是真实LIS
✅ 掌握双序列DP的核心思想：用二维状态表示两个序列的匹配关系
✅ 理解哨兵技巧：多一行一列处理边界条件
✅ 精通滚动数组优化：观察依赖关系，减少空间复杂度
✅ 建立完整的代码检查机制，显著减少语法错误
🎯 序列DP和双序列DP已掌握，可以挑战树形DP或区间DP

**明日计划**: 继续动态规划专题(背包问题变种、区间DP 或 树形DP)

---

#### Day 4 下午 - 2025/08/08  
**今日目标**: 区间动态规划入门

**完成题目**:
- [x] 516. 最长回文子序列 (Medium) - 状态: 🔥 时间: 45min
  - 思路: 区间DP - dp[i][j] = s[i..j]范围内的最长回文子序列长度
  - 难点: 理解"滑动窗口式"的区间遍历顺序，掌握大区间依赖小区间的转移
  - 代码模板: 三种实现方式对比 - 区间DP、记忆化搜索、LCS转化
  - 延伸题目: 5. 最长回文子串、312. 戳气球、87. 扰乱字符串
  - 易错点: 循环遍历顺序、边界条件、记忆化搜索参数遗漏

**易错点详细记录**:
1. **循环遍历顺序**: 最初按坐标遍历，应该按区间长度递增遍历
2. **边界条件**: `len < n` 应该是 `len <= n`（包含最大长度）
3. **循环边界**: `i < len` 应该是 `i <= n - len`（保证j不越界）
4. **公式错误**: `j = len - i - 1` 应该是 `j = i + len - 1`
5. **记忆化参数**: helper函数调用时忘记传递memo参数

**核心突破**:
- ✅ 理解区间DP的"滑动窗口"思维：固定窗口大小，在字符串上滑动
- ✅ 掌握按区间长度递增的遍历策略：确保大区间计算时小区间已完成
- ✅ 理解状态转移的两种情况：两端匹配vs不匹配的处理逻辑
- ✅ 掌握与LCS问题的巧妙联系：回文子序列=原串与反转串的LCS

**今日总结**: 
✅ 掌握区间DP的核心思想：按区间长度递增的遍历策略
✅ 理解"滑动窗口式"的区间遍历，解决了循环逻辑理解难点
✅ 精通状态转移逻辑：两端匹配+2，不匹配选择最优子区间
✅ 掌握三种实现方式：区间DP、记忆化搜索、LCS转化思想
✅ 建立区间DP与其他DP类型的对比理解：端点处理vs序列匹配
🎯 区间DP已掌握，DP知识体系更加完整，可以挑战更复杂的DP问题

---

#### Day 5 - 2025/08/08
**今日目标**: 二叉树入门 - 深度计算

**完成题目**:
- [x] 104. 二叉树的最大深度 (Easy) - 状态: 🔥 时间: 60min
  - 思路: 三种方法 - 递归DFS、BFS层序遍历、DFS栈模拟
  - 难点: 理解树形递归思维，掌握不同遍历方式的实现差异
  - 代码模板: 二叉树递归模板、BFS层序遍历模板、栈模拟递归模板
  - 延伸题目: 111. 二叉树的最小深度、110. 平衡二叉树

**今日总结**: 
✅ 成功从DP专题切换到二叉树专题
✅ 掌握二叉树递归的核心思维：大树问题分解为子树问题
✅ 理解三种实现方式的本质区别：递归、BFS、栈模拟
✅ 精通空间复杂度分析：O(h)递归栈 vs O(w)队列宽度
✅ 建立完整的测试体系：标准树、单节点、空树、偏斜树
✅ 掌握C++17的结构化绑定语法：auto [node, depth] = st.top()
🎯 二叉树基础已扎实，递归思维与DP记忆化搜索相通，可以挑战更复杂的树形问题

---

#### Day 6 - 2025/08/09 (上午)
**今日目标**: 二叉树变换 + 智能复习系统

**智能复习完成**:
- [x] 复习系统分析 - 识别高频错误题目并制定复习策略
  - 300题: ❌ 发现新错误 - DP返回值理解错误(return dp[n-1] vs max_element)
  - 516题: ⚡ 记忆化搜索递归公式不熟练
  - 322题: ⚡ 思路清晰但细节生疏
  - 效果: 及时发现概念漏洞，加深理解"以位置结尾"vs"前缀范围"的状态定义区别

**完成题目**:
- [x] 226. 翻转二叉树 (Easy) - 状态: 🔥 时间: 40min
  - 思路: 三种实现方式本质相同 - 递归DFS、BFS层序遍历、DFS栈模拟
  - 核心洞察: 算法的"局部独立性"特征 - 每个节点只管自己的左右子树交换
  - 深度思考: BFS≈DFS的适用条件、栈版本中交换后访问顺序变化的影响分析
  - 代码模板: 树形递归标准模板、BFS/DFS迭代版本对比
  - 延伸题目: 101. 对称二叉树、100. 相同的树、951. 翻转等价二叉树
  - 易错点修复: 递归指针保存顺序、BFS容器类型错误(st.push vs q.push)

**重要概念突破**:
- **算法分类框架**:
  - 类型A (局部独立): BFS≈DFS，选择最简洁实现
  - 类型B (全局依赖): BFS≠DFS，根据需求选择
- **树形递归精髓**: 大问题自然分解为子问题的递归结构
- **DP状态定义复习**: "以位置结尾"需要全局最大值，"前缀范围"返回最后状态

#### Day 6 - 2025/08/09 (下午)
**继续目标**: 二叉树遍历 - 栈模拟递归

**完成题目**:
- [x] 94. 二叉树的中序遍历 (Medium) - 状态: 🔥 时间: 45min
  - 思路: 递归版本 + 迭代版本(栈模拟递归)
  - 核心洞察: 掌握栈模拟递归的通用模式 - "向左深入→弹栈访问→右转重复"
  - 深度理解: curr指针驱动循环的本质，栈保存回溯路径的原理
  - 代码模板: 栈模拟递归通用框架，可推广到前序、后序遍历
  - 延伸题目: 144. 前序遍历、145. 后序遍历、98. 验证BST
  - 特殊性质: BST的中序遍历结果有序，可用于验证和查找第K小元素

**技术突破**:
- **栈模拟递归核心理解**: 
  - curr是状态指针，控制深入和转移
  - 栈保存待访问的父节点序列
  - 三阶段循环：深入→处理→转移
- **中序遍历特殊价值**: 在BST中产生有序序列，是很多BST算法的基础
- **迭代vs递归权衡**: 迭代避免栈溢出，递归代码更简洁

**今日总结**: 
✅ 建立了算法分类的思维框架，提升了算法本质理解能力
✅ 掌握树形递归的核心思维，理解局部独立性的算法特征
✅ 复习系统显效，及时发现并修正概念理解错误
✅ 精通栈模拟递归的通用模式，可推广到多种树形问题
✅ 深度思考能力提升：从实现细节到算法本质的抽象分析
✅ 二叉树专题进展顺利，递归思维与之前DP经验形成良性互补
🎯 掌握了栈模拟递归这一重要的算法模式，算法思维层次显著提升

**明日计划**: 继续二叉树专题(101.对称二叉树 或 98.验证BST) + 前序/后序遍历对比学习 

## 🔄 复习计划

### 需要3天后复习 ❌
- [ ] 题目名称 - 日期

### 需要1周后复习 ⚡  
- [ ] 题目名称 - 日期

### 需要1月后复习 🔥
- [ ] 题目名称 - 日期

## 📝 知识点总结

### 算法模板库

#### 双指针
```cpp
// 对撞指针 - 盛最多水的容器
int maxArea(vector<int>& height) {
    int left = 0, right = height.size() - 1;
    int maxArea = 0;
    while (left < right) {
        int currentArea = min(height[left], height[right]) * (right - left);
        maxArea = max(maxArea, currentArea);
        if (height[left] < height[right]) left++;
        else right--;
    }
    return maxArea;
}

// 三数之和 - 排序 + 双指针 + 去重
vector<vector<int>> threeSum(vector<int>& nums) {
    vector<vector<int>> result;
    sort(nums.begin(), nums.end());
    for (int i = 0; i < nums.size(); i++) {
        if (i > 0 && nums[i] == nums[i-1]) continue;  // 去重
        int left = i + 1, right = nums.size() - 1;
        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            if (sum == 0) {
                result.push_back({nums[i], nums[left], nums[right]});
                while (left < right && nums[left] == nums[left+1]) left++;
                while (left < right && nums[right] == nums[right-1]) right--;
                left++; right--;
            } else if (sum < 0) left++;
            else right--;
        }
    }
    return result;
}
```

#### 滑动窗口 + 单调队列
```cpp
// 滑动窗口最大值 - 单调队列模板
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    vector<int> result;
    deque<int> dq;  // 存储下标，保持递减顺序
    
    for (int i = 0; i < nums.size(); i++) {
        // 移除过期元素（超出窗口范围）
        while (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }
        
        // 维护单调性（移除所有比当前元素小的元素）
        while (!dq.empty() && nums[dq.back()] <= nums[i]) {
            dq.pop_back();
        }
        
        dq.push_back(i);  // 添加当前元素下标
        
        // 当窗口满时，队首就是最大值
        if (i >= k - 1) {
            result.push_back(nums[dq.front()]);
        }
    }
    return result;
}

// 通用滑动窗口模板
def sliding_window(s):
    left = 0
    result = 0
    for right in range(len(s)):
        # 扩大窗口
        # 收缩窗口
        while condition:
            left += 1
        # 更新结果
        result = max(result, right - left + 1)
```

#### 链表操作
```python
# 链表反转
def reverse_list(head):
    prev, curr = None, head
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    return prev
```

### 易错点记录
1. **边界条件处理**
   - 空数组/空链表
   - 单元素情况
   - 数组越界

2. **算法实现细节**
   - 循环条件 (< vs <=)
   - 指针更新顺序
   - 返回值处理

3. **今日易错点**
   - **双指针移动策略**: 记住总是移动较矮/较小的指针
   - **去重处理**: 三数之和需要三层去重，容易遗漏
   - **边界检查**: while循环中的`left < right`条件很重要

## 🎯 阶段性目标

### 第1-2周目标
- [ ] 完成数组双指针专题 (10题)
- [ ] 掌握基础滑动窗口模板
- [ ] 熟练链表基本操作

### 第3-4周目标  
- [ ] 完成栈队列专题 (7题)
- [ ] 掌握单调栈模板
- [ ] 开始动态规划入门

### 第5-6周目标
- [ ] 完成树和回溯专题 (20题) 
- [ ] 建立完整的算法知识框架
- [ ] 达到70%题目熟练掌握

## 💡 学习心得

### 本周收获 (Day 1)
- 学到的新技巧: 双指针对撞模式、三层去重策略、排序辅助算法优化
- 理解深刻的题目: 15. 三数之和 - 将O(n³)优化到O(n²)的经典案例
- 需要加强的地方: 去重逻辑的细节处理，需要多练习类似题目

### 优化建议
- 时间管理:
- 学习方法:
- 复习策略:

---

## 使用说明

1. **每日更新**: 完成题目后立即更新状态和笔记
2. **状态含义**: 
   - 🔥 熟练掌握 (10分钟内独立AC)
   - ⚡ 基本理解 (需要提示但能完成)  
   - ❌ 需要复习 (无法独立完成)
3. **复习提醒**: 根据遗忘曲线安排复习时间
4. **模板积累**: 及时总结代码模板和解题套路
5. **定期回顾**: 每周总结学习效果，调整计划