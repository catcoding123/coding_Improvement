# 二叉树与图论专题

## 二叉树算法体系

本专题目录
- [104. 二叉树最大深度](#bt-104)
- [226. 翻转二叉树](#bt-226)
- [94. 二叉树中序遍历](#bt-94)
- [98. 验证BST](#bt-98)
- [230. BST第K小元素](#bt-230)
- [101. 对称二叉树](#bt-101)
- [99. 恢复BST](#bt-99)
- [108. 将有序数组转换为BST](#bt-108)

## 图论算法体系

本专题目录
- [200. 岛屿数量](#graph-200)

<a id="bt-104"></a>
### 104. 二叉树最大深度 (Easy) - 递归入门
**核心思想**: 大树问题分解为子树问题
**递归公式**: `max(左深度, 右深度) + 1`
**三种实现**: 递归DFS、BFS层序、DFS栈模拟

<a id="bt-226"></a>
### 226. 翻转二叉树 (Easy) - 树形变换
**核心洞察**: 算法局部独立性，每个节点只管自己的左右交换
**重要**: BFS≈DFS适用于局部独立操作
**易错**: 递归时先保存子树指针再交换

<a id="bt-94"></a>
### 94. 二叉树中序遍历 (Medium) - 栈模拟递归
**核心模式**: "向左深入→弹栈访问→右转重复"
**关键**: curr指针驱动，栈保存回溯路径
**应用**: BST中序遍历有序，可用于验证和查找

<a id="bt-98"></a>
### 98. 验证BST (Medium) - 引用传递+中序遍历
**核心思想**: 利用BST中序遍历严格递增性质
**关键突破**: 引用传递`TreeNode*& prev`维护全局前驱状态
**BST定义**: 不是简单父子关系，而是整体子树约束

<a id="bt-230"></a>
### 230. BST第K小元素 (Medium) - 知识融合+提前终止
**核心思想**: 中序遍历+计数器+提前终止优化
**知识融合**: 98题BST性质 + 94题中序遍历 + 引用传递
**效率优化**: O(H+k) vs O(n)，提前终止避免无效遍历
**通用模式**: BST+中序遍历可扩展到99、108、173等题

<a id="bt-101"></a>
### 101. 对称二叉树 (Easy) - 双节点递归突破
**算法革命**: 从单节点递归到双节点同步递归的思维跃迁
**对称关系**: 左左↔右右、左右↔右左的交叉对应
**递归设计**: 双参数、边界处理、镜像调用的系统思考
**实现对比**: 递归版本vs迭代队列的双重掌握

<a id="bt-99"></a>
### 99. 恢复BST (Hard) - 逆序对识别+状态管理
**核心算法**: 中序遍历+逆序对识别+节点值交换
**逆序对模式**: 
- 相邻交换: 一个逆序对 `[1,3,2,4]` → 同时设置firstError/secondError
- 不相邻交换: 两个逆序对 `[1,4,3,2,5]` → 第二次仅更新secondError
**状态管理**: 三指针协调 - prev、firstError、secondError
**进阶扩展**: Morris遍历实现O(1)空间复杂度
**易错点**: 相邻交换需同时设置两个错误节点，不相邻交换分两次设置

<a id="bt-108"></a>
### 108. 将有序数组转换为BST (Easy) - 分治构建+平衡保证
**核心思想**: 分治递归构建，选择中点作为根节点保证平衡性
**算法流程**: 
- 选择中点: `mid = (left + right) / 2` 
- 创建根节点: `root = new TreeNode(nums[mid])`
- 递归构建: 左子树`[left, mid-1]`，右子树`[mid+1, right]`
**平衡原理**: 中点选择保证左右子树大小相近，高度差≤1
**知识闭环**: 验证(98)→应用(230)→恢复(99)→构建(108)完整BST生命周期
**时间复杂度**: O(n) - 每个节点创建一次
**空间复杂度**: O(log n) - 递归栈深度
**易错点**: 创建节点用`nums[mid]`不是`mid`，边界条件`left > right`
**技术突破**: 引用传递维护全局前驱状态
**经典陷阱**: BST不是简单父子关系，而是子树整体约束
```cpp
bool inorderCheck(TreeNode* node, TreeNode*& prev) {
    if (!node) return true;
    if (!inorderCheck(node->left, prev)) return false;
    if (prev && prev->val >= node->val) return false;
    prev = node;
    return inorderCheck(node->right, prev);
}
```

### 230. BST第K小元素 (Medium) - 知识融合+提前终止
**核心思想**: BST中序遍历+计数器，O(H+k)优化
**知识融合**: 98题BST性质 + 94题中序遍历 + 引用传递
**关键**: `k==0`时提前终止，避免继续递归

### 101. 对称二叉树 (Easy) - 双节点递归
**算法突破**: 从单节点递归跃升到双节点同步递归
**镜像定义**: 左左↔右右，左右↔右左的交叉对应
**边界处理**: 四种空节点组合的完整处理
```cpp
bool isMirror(TreeNode* left, TreeNode* right) {
    if (!left && !right) return true;
    if (!left || !right) return false;
    if (left->val != right->val) return false;
    return isMirror(left->left, right->right) && 
           isMirror(left->right, right->left);
}
```

---

## 图论算法核心体系

<a id="graph-200"></a>
### 200. 岛屿数量 (Medium) - 图论算法入门

**题目链接**: https://leetcode.cn/problems/number-of-islands/

#### 核心概念建立
**图论建模**: 二维网格 → 无向图
- **节点(顶点)**: 网格中的每个格子
- **边**: 相邻格子之间的连接关系(上下左右四方向)
- **连通分量**: 彼此连接的节点集合(每个岛屿就是一个连通分量)

#### 算法思维对比
**与回溯算法的联系**:
- **共同点**: 都使用递归进行深度优先搜索，边界处理，状态管理
- **核心差异**: 
  - 回溯算法: 解空间搜索 + 撤销操作，寻找所有可能解
  - 图遍历: 连通性搜索 + 标记机制，访问所有连通节点

**技能迁移**: 从131题字符串分割的递归思维迁移到200题二维网格搜索

#### DFS深度优先搜索实现
```cpp
void dfs(vector<vector<char>>& grid, int i, int j) {
    // 边界检查和终止条件
    if(i<0 || j<0 || i>=grid.size() || j >= grid[0].size() || grid[i][j] =='0') 
        return;
    
    // 标记当前格子为已访问
    grid[i][j] = '0';
    
    // 递归搜索四个方向的相邻格子
    dfs(grid, i-1, j);  // 上
    dfs(grid, i+1, j);  // 下  
    dfs(grid, i, j-1);  // 左
    dfs(grid, i, j+1);  // 右
}
```

#### BFS广度优先搜索实现
```cpp
void bfs(vector<vector<char>>& grid, int i, int j) {
    queue<pair<int,int>> q;
    grid[i][j] = '0';  // 标记起始格子
    q.push({i,j});
    
    while(!q.empty()) {
        auto [i,j] = q.front();
        q.pop();
        
        // 边界检查
        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]=='0') 
            continue;
            
        grid[i][j] = '0';  // 标记当前格子
        
        // 将四个方向的相邻格子入队
        q.push({i-1,j}); q.push({i+1,j});
        q.push({i,j-1}); q.push({i,j+1});
    }
}
```

#### 算法分析
- **时间复杂度**: O(M×N) - 每个格子最多访问一次
- **空间复杂度**: O(M×N) - 最坏情况下递归栈深度(DFS)或队列大小(BFS)

#### 关键技术点
1. **标记机制**: 避免重复访问的关键，直接修改原数组将'1'改为'0'
2. **边界处理**: 严格的数组越界检查 
3. **方向遍历**: 上下左右四个方向的系统性搜索
4. **连通分量计数**: 每发现一个新的'1'，就找到了一个新岛屿

#### 易错点总结
1. **边界检查**: 数组越界的判断条件要完整
2. **标记时机**: DFS中先检查再标记，BFS中要注意起始节点的标记
3. **队列类型**: BFS使用`queue<pair<int,int>>`存储坐标
4. **结构化绑定**: C++17特性`auto [i,j] = q.front()`

#### 算法扩展应用
- **岛屿类变种**: 695题(最大岛屿面积)、463题(岛屿周长)
- **连通分量**: 547题(朋友圈)、130题(被围绕的区域)
- **图遍历**: 为后续复杂图论算法(最短路径、最小生成树)打基础

#### 学习里程碑
**图论思维建立**: 从回溯算法的递归思维成功迁移到图遍历算法
**算法跃迁**: 从单一数据结构(数组、链表、树)扩展到复杂图结构
**遍历策略**: 同时掌握DFS递归和BFS队列两种核心图遍历方法
**为后续铺路**: 建立图论基础概念，为复杂图算法学习奠定基础
