# 二叉树专题

本专题目录
- [104. 二叉树最大深度](#bt-104)
- [226. 翻转二叉树](#bt-226)
- [94. 二叉树中序遍历](#bt-94)
- [98. 验证BST](#bt-98)
- [230. BST第K小元素](#bt-230)
- [101. 对称二叉树](#bt-101)
- [99. 恢复BST](#bt-99)
- [108. 将有序数组转换为BST](#bt-108)

<a id="bt-104"></a>
### 104. 二叉树最大深度 (Easy) - 递归入门
**核心思想**: 大树问题分解为子树问题
**递归公式**: `max(左深度, 右深度) + 1`
**三种实现**: 递归DFS、BFS层序、DFS栈模拟

<a id="bt-226"></a>
### 226. 翻转二叉树 (Easy) - 树形变换
**核心洞察**: 算法局部独立性，每个节点只管自己的左右交换
**重要**: BFS≈DFS适用于局部独立操作
**易错**: 递归时先保存子树指针再交换

<a id="bt-94"></a>
### 94. 二叉树中序遍历 (Medium) - 栈模拟递归
**核心模式**: "向左深入→弹栈访问→右转重复"
**关键**: curr指针驱动，栈保存回溯路径
**应用**: BST中序遍历有序，可用于验证和查找

<a id="bt-98"></a>
### 98. 验证BST (Medium) - 引用传递+中序遍历
**核心思想**: 利用BST中序遍历严格递增性质
**关键突破**: 引用传递`TreeNode*& prev`维护全局前驱状态
**BST定义**: 不是简单父子关系，而是整体子树约束

<a id="bt-230"></a>
### 230. BST第K小元素 (Medium) - 知识融合+提前终止
**核心思想**: 中序遍历+计数器+提前终止优化
**知识融合**: 98题BST性质 + 94题中序遍历 + 引用传递
**效率优化**: O(H+k) vs O(n)，提前终止避免无效遍历
**通用模式**: BST+中序遍历可扩展到99、108、173等题

<a id="bt-101"></a>
### 101. 对称二叉树 (Easy) - 双节点递归突破
**算法革命**: 从单节点递归到双节点同步递归的思维跃迁
**对称关系**: 左左↔右右、左右↔右左的交叉对应
**递归设计**: 双参数、边界处理、镜像调用的系统思考
**实现对比**: 递归版本vs迭代队列的双重掌握

<a id="bt-99"></a>
### 99. 恢复BST (Hard) - 逆序对识别+状态管理
**核心算法**: 中序遍历+逆序对识别+节点值交换
**逆序对模式**: 
- 相邻交换: 一个逆序对 `[1,3,2,4]` → 同时设置firstError/secondError
- 不相邻交换: 两个逆序对 `[1,4,3,2,5]` → 第二次仅更新secondError
**状态管理**: 三指针协调 - prev、firstError、secondError
**进阶扩展**: Morris遍历实现O(1)空间复杂度
**易错点**: 相邻交换需同时设置两个错误节点，不相邻交换分两次设置

<a id="bt-108"></a>
### 108. 将有序数组转换为BST (Easy) - 分治构建+平衡保证
**核心思想**: 分治递归构建，选择中点作为根节点保证平衡性
**算法流程**: 
- 选择中点: `mid = (left + right) / 2` 
- 创建根节点: `root = new TreeNode(nums[mid])`
- 递归构建: 左子树`[left, mid-1]`，右子树`[mid+1, right]`
**平衡原理**: 中点选择保证左右子树大小相近，高度差≤1
**知识闭环**: 验证(98)→应用(230)→恢复(99)→构建(108)完整BST生命周期
**时间复杂度**: O(n) - 每个节点创建一次
**空间复杂度**: O(log n) - 递归栈深度
**易错点**: 创建节点用`nums[mid]`不是`mid`，边界条件`left > right`
**技术突破**: 引用传递维护全局前驱状态
**经典陷阱**: BST不是简单父子关系，而是子树整体约束
```cpp
bool inorderCheck(TreeNode* node, TreeNode*& prev) {
    if (!node) return true;
    if (!inorderCheck(node->left, prev)) return false;
    if (prev && prev->val >= node->val) return false;
    prev = node;
    return inorderCheck(node->right, prev);
}
```

### 230. BST第K小元素 (Medium) - 知识融合+提前终止
**核心思想**: BST中序遍历+计数器，O(H+k)优化
**知识融合**: 98题BST性质 + 94题中序遍历 + 引用传递
**关键**: `k==0`时提前终止，避免继续递归

### 101. 对称二叉树 (Easy) - 双节点递归
**算法突破**: 从单节点递归跃升到双节点同步递归
**镜像定义**: 左左↔右右，左右↔右左的交叉对应
**边界处理**: 四种空节点组合的完整处理
```cpp
bool isMirror(TreeNode* left, TreeNode* right) {
    if (!left && !right) return true;
    if (!left || !right) return false;
    if (left->val != right->val) return false;
    return isMirror(left->left, right->right) && 
           isMirror(left->right, right->left);
}
```
