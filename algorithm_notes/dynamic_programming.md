# 动态规划专题

## 专题概述

动态规划是算法面试的重点和难点，通过将复杂问题分解为重叠子问题，利用最优子结构性质高效求解。本专题涵盖：
- **基础DP**: 爬楼梯、打家劫舍、最大子数组和
- **序列DP**: 最长递增子序列、最长公共子序列
- **背包问题**: 零钱兑换、完全背包、01背包
- **区间DP**: 最长回文子序列、矩阵链乘法

**核心思想**: 状态定义 + 转移方程 + 边界条件，通过记忆化避免重复计算。

## 核心题目

### 70. 爬楼梯 (Easy) - DP入门
**状态定义**: `dp[i]` = 爬到第i阶的方法数
**转移方程**: `dp[i] = dp[i-1] + dp[i-2]`
**四种实现**: 递归、记忆化、DP、空间优化

### 198. 打家劫舍 (Medium) - 决策类DP
**状态定义**: `dp[i]` = 偷前i+1间房的最大金额
**转移方程**: `dp[i] = max(nums[i] + dp[i-2], dp[i-1])`
**核心**: 每步做选择决策，约束影响状态转移

### 53. 最大子数组和 (Medium) - 连续子数组DP
**核心算法**: Kadane算法
**转移方程**: `dp[i] = max(nums[i], dp[i-1] + nums[i])`
**关键理解**: "继续vs重新开始"的决策

### 322. 零钱兑换 (Medium) - 完全背包
**状态定义**: `dp[i]` = 组成金额i的最少硬币数
**转移方程**: `dp[i] = min(dp[i-coin] + 1)`
**关键**: 完全背包允许重复使用，内层循环可用已更新值
**易错点**: 记忆化搜索必须检查 `helpResult != -1`，防止将无解状态累加
**记忆口诀**: "无解传递毁全局，-1检查是关键"

```cpp
// ❌ 错误：忘记无解检查
int result = helper(amount - coin) + 1;

// ✅ 正确：检查无解状态
int helpResult = helper(amount - coin);
if (helpResult != -1) {
    result = min(result, helpResult + 1);
}
```

### 300. 最长递增子序列 (Medium) - 序列DP
**状态定义**: `dp[i]` = 以nums[i]结尾的LIS长度
**优化**: 贪心+二分查找达到O(n log n)
**易错**: 返回`max(dp)`而非`dp[n-1]`

### 1143. 最长公共子序列 (Medium) - 双序列DP
**状态定义**: `dp[i][j]` = 两序列前缀LCS长度
**转移**: 匹配时`dp[i-1][j-1]+1`，不匹配时取最优
**优化**: 滚动数组降低空间复杂度

### 516. 最长回文子序列 (Medium) - 区间DP
**状态定义**: `dp[i][j]` = s[i..j]的回文子序列长度
**关键**: 按区间长度递增遍历
**转移**: 两端匹配+2，不匹配选择最优子区间

## DP核心模板

### 基础DP模板
```cpp
// 一维DP模板
vector<int> dp(n + 1);
dp[0] = 初始值;  // 边界条件

for (int i = 1; i <= n; i++) {
    for (每个可能的选择 choice) {
        dp[i] = min/max(dp[i], dp[i-cost] + value);
    }
}
return dp[n];
```

### 记忆化搜索模板
```cpp
class Solution {
private:
    vector<int> memo;
    
    int dfs(int state) {
        // 边界条件
        if (state == 边界) return 边界值;
        
        // 检查缓存
        if (memo[state] != -1) return memo[state];
        
        // 状态转移
        int result = 初始值;
        for (每个选择 choice) {
            int subResult = dfs(new_state);
            if (subResult != -1) {  // 检查无解状态
                result = min/max(result, subResult + cost);
            }
        }
        
        return memo[state] = (result == 初始值 ? -1 : result);
    }
    
public:
    int solve(输入参数) {
        memo.assign(状态空间大小, -1);
        return dfs(初始状态);
    }
};
```

### 完全背包模板
```cpp
// 完全背包：物品可重复使用
vector<int> dp(amount + 1, INT_MAX);
dp[0] = 0;

for (int coin : coins) {           // 先遍历物品
    for (int i = coin; i <= amount; i++) {  // 再遍历容量
        if (dp[i - coin] != INT_MAX) {
            dp[i] = min(dp[i], dp[i - coin] + 1);
        }
    }
}
```

### 01背包模板
```cpp
// 01背包：物品只能使用一次
vector<int> dp(capacity + 1, 0);

for (int i = 0; i < items.size(); i++) {        // 先遍历物品
    for (int j = capacity; j >= weight[i]; j--) { // 逆序遍历容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

### 区间DP模板
```cpp
// 区间DP：按区间长度递增
vector<vector<int>> dp(n, vector<int>(n, 0));

// 初始化长度为1的区间
for (int i = 0; i < n; i++) {
    dp[i][i] = 基础值;
}

// 按区间长度递增遍历
for (int len = 2; len <= n; len++) {
    for (int i = 0; i <= n - len; i++) {
        int j = i + len - 1;
        
        // 状态转移
        if (s[i] == s[j]) {
            dp[i][j] = dp[i+1][j-1] + 2;
        } else {
            dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
        }
    }
}
```

## DP设计思路

### 1. 状态定义
- **关键**: 状态要能表示问题的子问题
- **技巧**: 通常以位置、容量、长度作为状态维度
- **原则**: 状态数要可控，避免维度爆炸

### 2. 转移方程
- **决策**: 每个状态有哪些选择
- **约束**: 什么条件下可以转移
- **优化**: 取最大值、最小值或计数

### 3. 边界条件
- **初始状态**: 最小子问题的答案
- **无效状态**: 用特殊值标记无解状态
- **边界检查**: 避免数组越界

### 4. 计算顺序
- **依赖关系**: 确保计算当前状态时依赖的状态已计算
- **遍历方向**: 一般从小到大，区间DP按长度递增
- **空间优化**: 滚动数组、状态压缩

## 易错点总结

1. **无解状态检查**: 记忆化搜索中必须检查子问题是否有解
2. **初始化**: 注意DP数组的初始值设置（0、-1、INF等）
3. **返回值**: 注意返回的是dp[n]还是max(dp)
4. **遍历顺序**: 完全背包正序，01背包逆序
5. **边界条件**: 空数组、单元素等特殊情况
6. **状态转移**: 确保所有可能的转移都考虑到
7. **优化方向**: 最大化问题用max，最小化问题用min

## 相关题目分类

- **基础DP**: 70爬楼梯、198打家劫舍、53最大子数组和、121买卖股票
- **序列DP**: 300最长递增子序列、1143最长公共子序列、72编辑距离
- **背包问题**: 322零钱兑换、518零钱兑换II、416分割等和子集
- **区间DP**: 516最长回文子序列、1039多边形三角剖分、312戳气球
- **状态机DP**: 309买卖股票含冷冻期、188买卖股票IV
- **数位DP**: 233数字1的个数、357统计各位数字都不同的数字个数

---
*动态规划的精髓在于找到状态转移的递推关系，通过空间换时间避免重复计算*