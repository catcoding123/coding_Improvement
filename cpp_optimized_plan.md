# C++ 优化刷题计划

## 🚀 基于已学知识的高效策略

### 题目处理策略
- **🟢 已掌握简单题**: 直接跳过，节省时间
- **🟡 已学中等题**: 5-10分钟C++快速实现
- **🔴 已学困难题**: 深度学习，做延伸题目
- **⚪ 未学题目**: 正常流程，重点攻克

## 📅 第一周优化计划

### Day 1: 数组双指针复习 + 新题
**快速复习 (30分钟)**:
- [ ] 11. 盛最多水的容器 - C++实现 (5分钟)
- [ ] 15. 三数之和 - C++实现 (10分钟)  
- [ ] 42. 接雨水 - 多种解法对比 (15分钟)

**新题攻克 (60分钟)**:
- [ ] 287. 寻找重复数 (Medium) - 未学
- [ ] 41. 缺失的第一个正数 (Hard) - 已学但需加深

### Day 2: 滑动窗口强化
**快速复习 (20分钟)**:
- [ ] 3. 无重复字符的最长子串 - C++实现
- [ ] 76. 最小覆盖子串 - 模板总结

**新题 + 延伸 (70分钟)**:
- [ ] 239. 滑动窗口最大值 - 已学，多种解法
- [ ] 567. 字符串的排列 - 延伸题
- [ ] 209. 长度最小的子数组 - 新题

### Day 3: 链表快速复习 + 栈队列
**链表快速复习 (20分钟)**:
- [ ] 206. 反转链表 - C++实现 (5分钟)
- [ ] 141. 环形链表 - C++实现 (5分钟)
- [ ] 21. 合并两个有序链表 - C++实现 (5分钟)
- [ ] 2. 两数相加 - C++实现 (5分钟)

**栈队列新题 (70分钟)**:
- [ ] 20. 有效的括号 (Easy) - 跳过或快速实现
- [ ] 155. 最小栈 (Medium) - 新学
- [ ] 84. 柱状图中最大的矩形 (Hard) - 重点
- [ ] 394. 字符串解码 (Medium) - 新学

### Day 4: 动态规划入门
**DP基础题 (90分钟)**:
- [ ] 70. 爬楼梯 (Easy) - 基础理解
- [ ] 198. 打家劫舍 (Medium) - 新学
- [ ] 213. 打家劫舍 II (Medium) - 延伸
- [ ] 53. 最大子数组和 (Medium) - 已学，DP角度重新理解
- [ ] 152. 乘积最大子数组 (Medium) - 已学，加深理解

### Day 5: 二叉树快速复习
**二叉树核心题快速过 (60分钟)**:
- [ ] 94. 二叉树的中序遍历 - C++实现 (5分钟)
- [ ] 104. 二叉树的最大深度 - C++实现 (5分钟)
- [ ] 226. 翻转二叉树 - C++实现 (5分钟)
- [ ] 98. 验证二叉搜索树 - 已学，C++实现 (10分钟)
- [ ] 102. 二叉树的层序遍历 - 已学，C++实现 (10分钟)
- [ ] 105. 从前序与中序遍历序列构造二叉树 - 已学，加深 (25分钟)

**新题攻克 (30分钟)**:
- [ ] 543. 二叉树的直径 (Easy) - 新学

### Day 6-7: 周末复习 + 错题巩固
- [ ] 复习本周所有题目
- [ ] 重做标记为困难的题目  
- [ ] 更新进度追踪
- [ ] 准备下周计划

## 📅 第二周计划：动态规划 + 回溯

### Day 8: 动态规划进阶
**背包问题系列 (90分钟)**:
- [ ] 416. 分割等和子集 (Medium) - 0/1背包
- [ ] 494. 目标和 (Medium) - 0/1背包变种
- [ ] 322. 零钱兑换 (Medium) - 完全背包
- [ ] 518. 零钱兑换 II (Medium) - 完全背包计数

### Day 9: 字符串DP
**字符串处理 (90分钟)**:
- [ ] 5. 最长回文子串 (Medium) - 已学，多种解法对比
- [ ] 647. 回文子串 (Medium) - 已学，DP解法
- [ ] 1143. 最长公共子序列 (Medium) - 经典DP
- [ ] 72. 编辑距离 (Hard) - 困难DP

### Day 10: 回溯算法入门  
**排列组合 (90分钟)**:
- [ ] 46. 全排列 (Medium) - 回溯基础
- [ ] 47. 全排列 II (Medium) - 去重技巧
- [ ] 78. 子集 (Medium) - 回溯经典
- [ ] 90. 子集 II (Medium) - 子集去重

### Day 11: 回溯进阶
**复杂回溯 (90分钟)**:
- [ ] 39. 组合总和 (Medium) - 组合问题
- [ ] 40. 组合总和 II (Medium) - 组合去重
- [ ] 22. 括号生成 (Medium) - 构造问题
- [ ] 79. 单词搜索 (Medium) - 二维回溯

### Day 12: 图论基础
**图的遍历 (90分钟)**:
- [ ] 200. 岛屿数量 (Medium) - 已学，DFS/BFS对比
- [ ] 695. 岛屿的最大面积 (Medium) - 岛屿变种
- [ ] 130. 被围绕的区域 (Medium) - 边界DFS
- [ ] 207. 课程表 (Medium) - 拓扑排序入门

### Day 13-14: 周末复习强化
- [ ] 动态规划专题复习
- [ ] 回溯算法模板总结
- [ ] 图论基础巩固

## 📅 第三周计划：高级算法

### Day 15: 二分查找专题
**二分查找变种 (90分钟)**:
- [ ] 704. 二分查找 (Easy) - 基础模板
- [ ] 34. 在排序数组中查找元素的第一个和最后一个位置 (Medium)
- [ ] 33. 搜索旋转排序数组 (Medium)
- [ ] 153. 寻找旋转排序数组中的最小值 (Medium)
- [ ] 4. 寻找两个正序数组的中位数 (Hard) - 困难题

### Day 16: 单调栈专题
**单调栈应用 (90分钟)**:
- [ ] 739. 每日温度 (Medium) - 已学，模板总结
- [ ] 496. 下一个更大元素 I (Easy) - 基础应用
- [ ] 503. 下一个更大元素 II (Medium) - 循环数组
- [ ] 42. 接雨水 (Hard) - 已学，单调栈解法
- [ ] 84. 柱状图中最大的矩形 (Hard) - 已学，加深理解

### Day 17: 高级数据结构
**Trie + 并查集 (90分钟)**:
- [ ] 208. 实现 Trie (Medium) - 已学，C++实现
- [ ] 212. 单词搜索 II (Hard) - Trie + 回溯
- [ ] 547. 省份数量 (Medium) - 并查集入门
- [ ] 200. 岛屿数量 (Medium) - 并查集解法

### Day 18: 贪心算法
**贪心策略 (90分钟)**:
- [ ] 55. 跳跃游戏 (Medium) - 贪心基础
- [ ] 45. 跳跃游戏 II (Medium) - 贪心优化
- [ ] 121. 买卖股票的最佳时机 (Easy) - 已学
- [ ] 122. 买卖股票的最佳时机 II (Medium) - 贪心策略
- [ ] 406. 根据身高重建队列 (Medium) - 复杂贪心

### Day 19: 位运算专题
**位运算技巧 (90分钟)**:
- [ ] 136. 只出现一次的数字 (Easy) - XOR基础
- [ ] 137. 只出现一次的数字 II (Medium) - 进阶位运算
- [ ] 260. 只出现一次的数字 III (Medium) - 分组XOR
- [ ] 191. 位1的个数 (Easy) - 基础计数
- [ ] 338. 比特位计数 (Easy) - DP + 位运算

### Day 20-21: 周末强化
- [ ] 高级算法专题复习
- [ ] 困难题重点攻克
- [ ] 算法模板整理

## 📅 第四周计划：综合应用

### Day 22: 设计类题目
**数据结构设计 (90分钟)**:
- [ ] 146. LRU 缓存 (Medium) - 已学，C++实现
- [ ] 460. LFU 缓存 (Hard) - 复杂设计
- [ ] 380. O(1) 时间插入、删除和获取随机元素 (Medium)
- [ ] 381. O(1) 时间插入、删除和获取随机元素 - 允许重复 (Hard)

### Day 23: 数学算法
**数学技巧 (90分钟)**:
- [ ] 202. 快乐数 (Easy) - 循环检测
- [ ] 204. 计数质数 (Medium) - 埃拉托斯特尼筛法
- [ ] 264. 丑数 II (Medium) - 多路归并
- [ ] 50. Pow(x, n) (Medium) - 快速幂

### Day 24: 字符串算法
**字符串高级技巧 (90分钟)**:
- [ ] 28. 找出字符串中第一个匹配项的下标 (Easy) - KMP算法
- [ ] 214. 最短回文串 (Hard) - KMP应用
- [ ] 6. N 字形变换 (Medium) - 模拟
- [ ] 8. 字符串转换整数 (atoi) (Medium) - 状态机

### Day 25: 复杂DP
**高级动态规划 (90分钟)**:
- [ ] 309. 最佳买卖股票时机含冷冻期 (Medium) - 状态机DP
- [ ] 188. 买卖股票的最佳时机 IV (Hard) - 通用股票DP
- [ ] 312. 戳气球 (Hard) - 区间DP
- [ ] 32. 最长有效括号 (Hard) - 已学，DP解法

### Day 26: 图论进阶
**最短路径 + 拓扑排序 (90分钟)**:
- [ ] 210. 课程表 II (Medium) - 拓扑排序
- [ ] 127. 单词接龙 (Hard) - BFS最短路径
- [ ] 743. 网络延迟时间 (Medium) - Dijkstra算法
- [ ] 787. K 站中转内最便宜的航班 (Medium) - 有限制的最短路径

### Day 27-28: 第四周总结
- [ ] 复杂算法专题复习
- [ ] 设计题总结
- [ ] 准备冲刺阶段

## 📅 第五-六周：冲刺强化

### 重点方向
- **高频面试题强化**
- **多解法对比学习**  
- **时间复杂度优化**
- **代码质量提升**
- **模拟面试练习**

### 题目查漏补缺
基于前4周的学习情况，重点攻克：
- 剩余的Hard题目
- 多解法的经典题
- 容易出错的题型
- 面试高频题目

## 🔧 C++ 刷题环境

### 基础模板
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <unordered_map>
#include <unordered_set>
#include <string>
#include <queue>
#include <stack>
#include <deque>
#include <climits>
#include <cassert>
using namespace std;

class Solution {
public:
    // 解法实现
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> mp;
        for (int i = 0; i < nums.size(); i++) {
            int complement = target - nums[i];
            if (mp.find(complement) != mp.end()) {
                return {mp[complement], i};
            }
            mp[nums[i]] = i;
        }
        return {};
    }
};

// 测试框架
void runTests() {
    Solution sol;
    
    // 测试用例
    vector<int> nums = {2, 7, 11, 15};
    int target = 9;
    vector<int> result = sol.twoSum(nums, target);
    vector<int> expected = {0, 1};
    
    assert(result == expected);
    cout << "Test passed! ✅" << endl;
}

// 性能测试
#include <chrono>
void performanceTest() {
    auto start = chrono::high_resolution_clock::now();
    // 大数据量测试
    auto end = chrono::high_resolution_clock::now();
    auto duration = chrono::duration_cast<chrono::microseconds>(end - start);
    cout << "Time: " << duration.count() << " microseconds" << endl;
}

int main() {
    runTests();
    performanceTest();
    return 0;
}
```

### C++ STL 常用工具
```cpp
// 容器
vector<int> arr;                    // 动态数组
unordered_map<int, int> mp;         // 哈希表
unordered_set<int> st;              // 哈希集合
queue<int> q;                       // 队列
stack<int> stk;                     // 栈
priority_queue<int> pq;             // 优先队列(大顶堆)
priority_queue<int, vector<int>, greater<int>> min_pq; // 小顶堆

// 算法
sort(arr.begin(), arr.end());       // 排序
reverse(arr.begin(), arr.end());    // 反转
binary_search(arr.begin(), arr.end(), target); // 二分查找
lower_bound(arr.begin(), arr.end(), target);   // 下界
upper_bound(arr.begin(), arr.end(), target);   // 上界

// 常用技巧
int maxVal = *max_element(arr.begin(), arr.end());
int minVal = *min_element(arr.begin(), arr.end());
```

## 📊 时间分配优化

### 原计划 vs 优化后
| 类型 | 原计划时间 | 优化后时间 | 节省时间 |
|------|-----------|-----------|---------|
| 已掌握简单题 | 60分钟 | 0分钟 | +60分钟 |
| 已学中等题 | 120分钟 | 60分钟 | +60分钟 |
| 已学困难题 | 60分钟 | 80分钟 | -20分钟 |
| 未学新题 | 60分钟 | 160分钟 | -100分钟 |

**净收益**: 可以多做40%的新题！

## 🎯 学习重点调整

### 1. C++语法熟练度
- **STL容器使用**: vector, map, set, queue, stack
- **算法函数**: sort, binary_search, lower_bound
- **现代C++特性**: auto, range-based for, lambda

### 2. 未涉及的重要算法
- **动态规划**: 背包问题、区间DP
- **高级图论**: 最短路径、拓扑排序
- **数学算法**: 位运算、数论

### 3. 系统化知识补充
- **设计类题目**: LRU缓存、数据结构设计
- **复杂数据结构**: Trie树、并查集
- **优化技巧**: 空间换时间、预处理

## 🔄 复习策略调整

### 已学题目复习频率
- **熟练题目**: 2周复习一次，重点关注C++实现
- **理解题目**: 1周复习一次，加深理解
- **困难题目**: 3天复习一次，做变种题

### C++代码质量要求
- **代码简洁**: 使用STL和现代C++特性
- **异常处理**: 考虑边界条件和异常情况
- **性能优化**: 时间复杂度和空间复杂度最优

这样的优化让你能在相同时间内学到更多新知识，同时巩固已有基础。